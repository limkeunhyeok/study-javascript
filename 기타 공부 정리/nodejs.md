# Node.js

## 개요

- 공식 사이트에서 node.js를 다음과 같이 설명하고 있다.

> Node.jsⓇ는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임입니다. Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.

- 노드는 자바스크립트 런타임이다.
  - 런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다.
  - 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해준다.
- 기존에는 자바스크립트 프로그램을 인터넷 브라우저 위에서만 실행할 수 있었고, 2008년 구글이 V8 엔진을 사용하여 크롬을 출시되어 속도 문제가 해결되자 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트를 시작했습니다.

![1](https://user-images.githubusercontent.com/38815618/88533217-e663b580-d040-11ea-8c38-247626c3f7dc.PNG)

- 노드는 V8과 더불어 libuv라는 라이브러리를 사용한다.
- V8과 libuv는 C와 C++로 구현되어 있으며, 작성한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해준다.
- libuv 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있다.

## 이벤트 기반

![2](https://user-images.githubusercontent.com/38815618/88533220-e6fc4c00-d040-11ea-8db9-d9f238f81581.PNG)

- 이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미하며, 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다.
- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 하며, 이것을 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고 표현한다.
- 노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출하며, 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기한다.

```javascript
function first () {
    second();
    console.log('첫 번째');
}

function second () {
    third();
    console.log('두 번째');
}

function third () {
    console.log('세 번째');
};

first();
// 세 번째
// 두 번째
// 첫 번째
```

- main 함수는 처음 실행 시의 전역 컨텍스트를 의미하며, 컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미한다.
- 함수의 실행이 완료되면 호출 스택에서 third, second, first, main 순으로 지워지고, main 함수까지 실행이 모두 완료되었다면 호출 스택은 비어있게 된다.

```javascript
function run () {
    console.log('3초 후 실행');
}

console.log('시작');
setTimeout(run, 3000);
console.log('끝');
// 시작
// 끝
// 3초 후 실행
```

![3](https://user-images.githubusercontent.com/38815618/88533223-e794e280-d040-11ea-8258-fa9800f73754.PNG)

- **이벤트 루프**: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불린다.
- **태스크 큐**: 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간이다. 콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부른다.
- **백그라운드**: 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳이다.

> 위 예시에서 먼저 전역 컨텍스트인 main 함수가 호출 스택에 들어가고, 그 뒤 setTimeout이 호출 스택에 들어간다. 호출 스택에 들어간 순서와 반대로 실행되므로 setTimeout이 먼저 실행된다. setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고 호출 스택에서 빠진다. 그 다음으로 main 함수가 호출 스택에서 빠진다. 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보낸다. 그림상으로는 태스크 큐가 하나의 큐처럼 보이지만 실제로는 여러 개의 큐로 이루어져 있다. 이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부르며, 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행한다.

## 논블로킹 I/O

- 논블로킹 방식은 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식이다.
- 논블로킹이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻한다.

![4](https://user-images.githubusercontent.com/38815618/88533224-e794e280-d040-11ea-8544-4ce2bb9ef0c2.PNG)

> 위의 그림을 보면 블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간 동안 처리할 수 있음을 알 수 있다. 하지만 싱글 스레드라는 한계 때문에 무조건 시간적 이득을 볼 수 있는 것은 아니다. 현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업이 주로 시간적 이득을 많이 본다.
I/O는 입출력을을 의미하며, 파일 시스템 접근(파일 읽기, 쓰기, 폴더 만들기 등)이나 네트워크 요청 같은 작업이 I/O의 일종이다. 이러한 작업을 할 때 노드는 논블로킹 방식으로 동작한다.

### 블로킹 방식

```javascript
function longRunningTask() {
    // 오래 걸리는 작업
    console.log('작업 끝');
}
console.log('시작');
longRunningTask();
console.log('다음 작업');

// 시작
// 작업 끝
// 다음 작업
```

- 동기와 블로킹 방식과 비동기와 논블로킹 방식이 유사하며, 위의 예시는 블로킹 방식의 코드이다.
- 작업이 오래 걸리는longRunningTask 함수가 있을 때, 이 작업이 완료되기 전까지 이어지는 console.log('다음 작업')이 호출되지 않는다.

### 논블로킹 방식

```javascript
function longRunningTask() {
    // 오래 걸리는 작업
    console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask(), 0);
console.log('다음 작업');

// 시작
// 다음 작업
// 작업 끝
```

- 위의 예시는 논블로킹 방식의 코드이다.
- setTimeout의 콜백 함수가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있으며, 다음 작업이 먼저 실행된 후, 오래 걸리는 작업이 완료된다.
- 브라우저와 노드사이에는 기본적인 지연 시간이 있어 0밀리초로 설정되어 있어도 바로 실행되지 않는다.

## 싱글 스레드

- 프로세스
  - 프로세스는 운영체제에서 할당하는 작업의 단위이다.
  - 노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스이다.
  - 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드
  - 스레드는 프로세스 내에서 실행되는 흐름의 단위이다.
  - 하나의 프로세스는 스레드를 여러 개 가질 수 있다.
  - 스레드들은 부모 프로세스의 자원을 공유한다.
  - 즉, 같은 메모리에 접근할 수 있다.

> 노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다. 반대로 멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있다. 자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문이다. 한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다.

- 스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈이다.
  - 요청이 많이 들어오면 한 번에 하나의 요청을 처리한다
  - 블로킹이 심하게 일어나지만 않는다면 하나로도 충분하다.

![5](https://user-images.githubusercontent.com/38815618/88533227-e82d7900-d040-11ea-8ab6-edc42a3f193f.PNG)

- 사실 노드 프로세스도 내부적으로는 스레드를 여러 개 가지고 있지만 직접 제어할 수 있는 스레드는 하나뿐이므로 흔히 싱글 스레드라고 부른다.
- 노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했다.
  - 자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다.

## 서버로서의 노드

|장점|단점|
|---|---|
|멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용함|싱글 스레드라서 CPU 코어를 하나만 사용함|
|I/O 작업이 많은 서버로 적합|CPU 작업이 많은 서버로는 부적합|
|멀티 스레드 방식보다 쉬움|하나뿐인 스레드가 멈추지 않도록 관리해야 함|
|웹 서버가 내장되어 있음|서버 규모가 커졌을 때 서버를 관리하기 어려움|
|자바스크립트를 사용함|어중간한 성능|
|JSON 형식과 호환하기 쉬움||

<p>
    노드는 개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는 데 적합하다. 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.
</p>

<p>
    노드가 아무리 좋다고 하더라도 추천하지 않는 경우도 있다. 이미지나 비디오 처리, 대규모 데이터 처리 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않는다.
</p>

<p>
    쇼핑몰, 블로그 같은 웹 사이트는 보통 기본적인 틀이 있고, 그 안의 내용물(텍스트, 이미지)만 조금씩 달라진다. 노드가 다른 서버 언어에 비해 이러한 콘텐츠를 제공하는 데 장점이 뚜렷하지는 않지만, Pug나 EJS 같은 템플릿 엔진을 통해서 다른 언어와 비슷하게 콘텐츠를 제공할 수 있다.
</p>

<p>
    안정성과 보안성 측면의 문제도 이미 충분히 검증되었다. 규모가 큰 곳을 꼽자면 미국항공우주국(NASA), 에어비엔비, 우버, 넷플릭스, 링크드인 등에서 노드를 사용하고 있다. 페이팔, 월마트, 이베이 같이 결제 시스템을 사용하는 대기업들도 노드로 서비스를 운영한다.
</p>

## 서버 외의 노드

<p>
    처음에는 대부분 노드를 서버로 사용했지만, 노드는 자바스크립트 런타임이기 때문에 용도가 서버에만 한정된 것은 아니다. 사용 범위가 점점 늘어나 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용되기 시작했다.
</p>

<p>
    노드 기반으로 돌아가는 대표적인 웹 프레임워크로는 Angular과 React, Vue, Meteor 등이 있다. Angular는 구글 진영에서 프런트엔드 앱을 만들 때 주로 사용하고, React는 페이스북 진영에서 주로 사용한다. 모바일 개발 도구로는 React Native와 Ionic Framework를 많이 사용한다. 페이스북, 인스타그램, 에어비앤비, 월마트, 테슬라 등이 React Native를 사용하여 모바일 앱을 운영 중이다. 데스크톱 개발 도구로는 Electron이 대표적이다. Electron으로 만들어진 프로그램으로는 Atom, Slack, Discord 등이 있다.
</p>
