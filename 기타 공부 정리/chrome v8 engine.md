# Chrome V8 Engine

## 개요

![그림1](https://user-images.githubusercontent.com/38815618/88693270-0fb43c80-d13a-11ea-9f3d-6cac62358b35.png)

> 공식 문서에 따르면, V8은 C++로 작성된 구글의 오픈소스 고성능 자바스크립트 및 WebAssembly 엔진이며 Chrome과 Node.js에서 사용된다. V8은 자바스크립트 소스 코드를 컴파일 및 실행하고, 객체의 메모리 할당을 처리하며 필요 없는 객체를 수집한다.(GC) 자바스크립트는 일반적으로 브라우저의 클라이언트 측 언어로 사용되며 DOM 객체를 조작하는데 사용된다. V8은 ECMA 표준에 지정된 데이터 타입, 연산자, 객체 및 기능을 제공한다. V8은 웹 브라우저 내부에서 자바스크립트 수행 속도의 개선을 목표로 처음 고안되었다.

## V8 동작 원리

![그림2](https://user-images.githubusercontent.com/38815618/88693272-10e56980-d13a-11ea-8c49-a321b4352a9e.jpg)

- **Parser**: 소스코드를 불러와 AST로 변환하는, 컴퓨터가 이해하기 쉽게 구조화한다.
- **Ignition**: 코드를 한 줄씩 실행할 때마다 코드를 바이트 코드로 변환하며 메모리 사용량 감소, 파싱 시 오버헤드 감소, 컴파일 파이프 라인의 복잡성 감소의 이점이 있다.
- **TurboFan**: 자주 사용하는 데이터를 모아 코드를 최적화 한다

![그림3](https://user-images.githubusercontent.com/38815618/88693275-10e56980-d13a-11ea-9443-c63942e02260.png)

1. 소스 코드를 먼저 Parser에게 넘기고, AST(Abstract Syntax Tree, 추상 구문 트리)로 변환한다.
2. AST를 Ignition으로 넘긴다. Ignition은 자바스크립트를 바이트 코드로 변환하는 인터프리터이다. 원본 소스 코드보다 컴퓨터가 해석하기 쉬운 바이트 코드로 변환함으로써 원본 코드를 다시 파싱해야하는 수고를 덜고, 코드의 양도 줄이면서 코드를 실행 때 차지하는 메모리 공간을 아낄 수 있다.
3. 바이트 코드를 실행하여 작성한 코드를 실제로 작동하게 되고 자주 사용하는 코드는 TuboFan으로 보내져 Optimized Machine Code 즉, 최적화된 코드로 다시 컴파일 된다. 사용이 줄어들면 Deoptimizing 되기도 한다.

- 기존에 사용되었던 Full-codegen과 Crankshaft는 새로운 자바스크립트의 기능과 요구사항에 따라갈 수 없기 때문에 V8에서 더 이상 사용되지 않는다.

## 최적화 기법: 히든 클래스

![그림4](https://user-images.githubusercontent.com/38815618/88693279-117e0000-d13a-11ea-8e37-59ec663e4368.png)

<p>
    자바스크립트는 프로토타입 기반 언어이다. 자바스크립트(오른쪽)는 수행 중간에 필드 구조가 변경될 수 있기 때문에 기본적으로 [프로퍼티 이름 + 값] 세트를 모든 객체가 들고 있어야 한다. 만약 객체 100개를 생성했는데, 100개가 모두 같은 필드 구조를 가지고 있다 해도 언제 바뀔 지 모르기 때문에 계속 저 테이블을 들고 다녀야 한다. 중복해서 나타나는 멤버 변수 이름을 다 가지고 있기 때문에 일단 메모리는 당연히 문제가 되고, 더불어 성능에도 문제가 생긴다.
</p>

![그림5](https://user-images.githubusercontent.com/38815618/88693282-12169680-d13a-11ea-8613-3962d469946f.png)

<p>
    히든 클래스란 자바스크립트에는 클래스가 없지만, 엔진 안쪽에 숨겨진 클래스 개념을 두는 최적화 기법이다. JSCell은 오브젝트를 담는 자료구조이고, Structure는 hidden class 자료구조이다. JSCell은 실제 프로퍼티 값들만을 저장하고, 대신 자신이 (현재) 속한 hidden class에 대한 포인터를 가지고 있다. m_propertyTable은 현재 나를 hidden class로 가지고 있는 오브젝트들이 어떤 필드 구조를 가지고 있고, 각각의 필드가 어느 오프셋에 저장되어 있는지를 나타내는 테이블이다. 객체의 멤버 변수를 참조할 때 이 테이블을 참조함으로써 어떤 위치의 값을 읽으면 되는지 알아낼 수 있는 것이다.
</p>

### 과정

![그림6](https://user-images.githubusercontent.com/38815618/88693284-12af2d00-d13a-11ea-9b8c-9335ef92e7d1.png)

1. 아무 필드가 없는 객체는 [Structure 0]을 참조한다.
2. a에 x 필드가 추가되면서, [Structure 1]이 생성되고, 프로퍼티 테이블에 x(offset = 0)가 추가된다.
3. [Structure 0]의 트랜지션 테이블에 x가 추가된다. 앞으로 [structure 0]을 가리키는 객체에서 x라는 필드가 추가된다면, 트랜지션 테이블을 참조하여 [Structure 1]로 옮겨가게 된다.
4. a.y = 2가 수행되면서 y라는 필드를 추가하려고 한다. x때와 마찬가지로, [Structure 2]를 만들고, [Structure 1]에 y가 추가되는 경우에 대한 링크를 만든다.
5. 최종적으로 a는 [Structure 2]를 가리키고 있으므로, x에 접근할 때는 offset 0번을, y에 접근할 때는 offset 1번을 가져다 쓰면 된다.

### 마지막 코드를 수행하면

![그림7](https://user-images.githubusercontent.com/38815618/88693287-1347c380-d13a-11ea-91ac-5df829a5adba.png)

1. b가 처음 만들어지면서 [Structure 0]을 가리키는데, x 프로퍼티가 추가된다.
2. [Structure 0]의 트랜지션 테이블을 보니 x가 추가될 때의 링크가 있기 때문에, b의 히든 클래스를 [Structure 1]로 변경한다.
3. 만약 여기서 b.y를 추가한다면 [Structure 2]를 가리키도록 변경될 것이다.
4. 만약 여기서 b.z를 추가한다면 새로운 [Structure 3]을 만들 것이고, [Structure 1]의 트랜지션 테이블에 z가 추가될 것이다.

## 최적화 기법: 인라인 캐싱

<p>
    Hidden class를 쓰게 되면 같은 필드를 가지는 객체가 많아질 경우 메모리는 확실히 절약될 수 있지만, 실제 필드에 접근해서 값을 가져오려면 객체->hidden class->프로퍼티 테이블->프로퍼티 비교->[오브젝트 + 오프셋] 위치로 접근이라는 단계를 거쳐야만 실제 필드에 접근할 수가 있게 되어 성능의 저하를 야기할 수 있다.
</p>

- 인라인 캐싱에는 다음과 같은 두 가지 가정이 바탕에 깔려 있다.
  - 동적인 언어라고 해봤자 실제로는 안바뀌는게 더 많다
  - 성능을 빠르게 하려면 딴 거 다 필요없고 루프를 노려라

<p>
    객체의 필드 구조가 런타임에 의해 변경될 수 있지만, 실제로는 자주 발생하지 않고, 더군다나 루프 안에서 변할 일은 거의 없을 것이다. 이 가정이 맞다면 인라인 캐싱은 높은 효율을 보여줄 것이고, 실제로 벤치마크를 돌렸을 때 인라인 캐싱 적용 유무가 엄청나게 큰 차이를 보이게 된다.
</p>

![그림8](https://user-images.githubusercontent.com/38815618/88693292-13e05a00-d13a-11ea-9c53-af50e5715c8f.png)

- 객체의 필드에 값을 쓸 때 생성되는 네이티브 코드
  - 처음 수행되었을 때에는 캐싱된 값이 없으므로, slow case (핸들러 함수, 비효율적)로 실행함. 이 때 찾은 오프셋 값과 히든 클래스(structure)를 constant pool 영역에 캐싱한다.
  - 다음번에 같은 필드에 접근할 때 캐싱된 structure와 현재 객체가 가리키는 structure의 주소값을 비교한다.
  - 만약 같다면 캐싱된 프로퍼티의 오프셋이 유효하다는 의미이므로, 아래쪽 코드 (파란색 영역)를 수행해서 바로 필드에 값을 저장한다.
  - 만약 다르다면 필드 구조가 달라졌다는 의미이므로, 오프셋 값이 무효가 됨. 이 경우에는 slow case 로 넘어가서 다시 캐싱하거나 아예 캐싱을 포기하도록 변경한다.

```javascript
for (var i = 0; i < 10; i++) {
    arr[i].x = i;
}
```

<p>
    위의 .x 부분에서 inline caching이 이루어진다. 첫 번째 iteration(i=0)에서는 캐싱된 값이 없기 때문에 slow case로 실행이 되고, arr[0]의 structure와 arr[0].x의 오프셋 값이 캐싱된다. 그런 다음 두 번째부터 마지막까지는 캐싱된 오프셋 값을 바로 쓸 수 있기 때문에 클래스 기반 언어와 똑같은 성능을 보이게 된다.
</p>

<p>
    단, arr[1]부터 arr[9]까지 모두 같은 필드 구조를 가지고 있어야만 성립된다. 따라서 arr에 서로 다른 필드 구조를 가지는 객체를 가지고 있다거나, 코드가 arr에 든 오브젝트에 새로운 x 필드를 추가해 주기 위해 작성된 코드라던가 하는 경우에는 인라인 캐싱의 혜택을 전혀 못 받게 되며, 오히려 더 손해를 본다.
</p>

<p>
    간략한 설명으로 첫 번째 수행에서 바로 캐싱을 한다고 언급했으나, 정확하게는 두 번째 수행부터 캐싱을 한다. 왜냐하면 한 번 수행된 코드는 한 번만 수행될 가능성이 높지만, 두 번 수행된 코드는 이후에 더 수행될 확률이 높기 때문이다.
</p>
