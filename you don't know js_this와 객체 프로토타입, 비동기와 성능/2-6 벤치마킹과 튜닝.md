# Part 2 비동기와 성능

## Chapter 6 벤치마킹과 튜닝

### 1. 벤치마킹

<p>
    자바스크립트 성능 벤치마킹은 주어진 작업 실행 시간 동안 측정한 결과를 보고 무엇을 알 수 있는지, 무엇을 알 수 없는지부터 파악하는 게 기본이다. 소요 시간만으로는 작업을 딱 한 번 실행할 때 그만큼 시간이 걸린다는 정도만 알 수 있다. 늘 그 속도로 돌아가리란 보장이 없다. 엔진/시스템이 그때그때 어떤 식으로 간섭을 일으킬지 예측할 수 없고 더 빨리 실행되야 하는 경우도 있다. 소요 시간이 4로 나왔다고 했을 때, 정확히 4밀리 초가 걸렸다고 단정 지을 수 없다. start, end 타임 스탬프를 얻는 과정에서도 지연이 발생할 수 있어 실제로는 4밀리 초 이하일 것이다.
</p>

#### 반복

<p>
    단순 평균치만으로는 전체 애플리케이션의 성능에 관하여 어떤 결론도 내리기 어렵다. 100회 반복 테스트를 한다 해도 이상점이 2개만 있어도 평균은 왜곡될 수 있고 여기서 도출된 결론을 반복 적용하면 왜곡된 사실은 더욱 부풀려진다.
</p>

<p>
    오류 빈도를 최소화하려면 사용 중인 타이머의 정확도에 따라 반복 테스트 시간을 결정해야 한다. 부정확한 타이머일수록 테스트 시간을 늘려 가능한 한 에러를 줄여야 한다. 15밀리 초 타이머로는 정확히 벤치마킹하기 어렵다. 이 타이머로 불확실성을 1% 이하로 낮추려면 적어도 750밀리 초는 테스트해야 한다.
</p>

<p>
    하지만 단지 샘플일 뿐이다. 왜곡을 확실히 상쇄하려면 평균을 낼 샘플이 많아야 한다. 또 최악의 샘플은 얼마나 느린지, 최고의 샘플은 얼마나 빠른지 그리고 이 최악/최고 간 격차는 얼마인지 파악해야 한다. 어느 것이 얼마나 빠르다고 하는 수치뿐 아니라 이 수치를 어느 정도 신뢰할 수 있을지 판단의 근거가 되는 정량적 데이터도 필요하다.
</p>

#### Benchmark.js

<p>
    유의미한, 신뢰할 수 있는 벤치마킹은 반드시 통계적으로 검증된 지침에 근거한다. 존-데이빗 달튼과 마티아스 바이넨스가 Benchmark.js라는 통계학적으로 검증된 벤치마킹 도구를 발표하였다.
</p>

```javascript
// Benchmark.js

function foo() {
    // 테스트할 작업들
}

var bench = new Benchmark(
    "foo text", // 테스트 명
    foo, // 테스트할 함수
    {
        // 추가 옵션
    }
);

bench.hz; // 초당 작업 개수
bench.stats.moe; // 한계 에러
bench.stats.variance; // 분산
```

<p>
    Benchmark.js는 브라우저 환경의 자바스크립트 테스팅에 주로 쓰지만 브라우저 이외의 환경에서도 사용할 수 있다.
</p>

### 2. 콘텍스트가 제일

<p>
    X, Y 작업 간 성능 비교 등 특정한 성능 벤치마킹을 할 때 콘텍스트를 살피는 걸 잊으면 안된다. 테스트 결과, X가 Y보다 빠른 것처럼 나왓다고 해서 쉽게 결론을 내릴 수 없다.
</p>

#### 엔진 최적화

<p>
    고립 테스트 결과, X가 Y보다 10밀리 초 빨랐다고 단순히 X는 Y보다 항상 빠를 것이라고 넘겨짚는 건 위험한 발상이다. 사실 성능은 다루기가 아주 까다롭다. 예를 들어 아래는 미세 성능을 테스트하는 코드이다.
</p>

```javascript
var twelve = "12";
var foo = "foo";

// 테스트 1
var X1 = parseInt(twelve);
var X2 = parseInt(foo);

// 테스트 2
var Y1 = Number(twelve);
var Y2 = Number(foo);
```

<p>
    `Number()`와는 다르게 `parseInt()`가 어떻게 작동할지는 `parseInt()` 인자가 foo인 경우 필경하는 일이 더 많거나 아니면 두 함수 모두 첫 번째 문자 'f'에서 멈출 테니 작업량은 엇비슷할 것으로 추측할 것이다. 사실 내부에서 무슨 일이 벌어질지 알 수 없으며, 추측만 무성할 뿐 확실한 결정을 내릴 만한 구체적인 증거는 없다. 실제 코드가 아닌 테스팅만으로 실제 결과를 알 수 없다.
</p>

### 3. jsPerf.com

<p>
    Benchmark.js는 자바스크립트 실행 환경에 구애받지 않고 코드 성능을 테스트할 수 있는 유용한 도구지만 신뢰할 수 있는 결론을 원한다면 다양한 환경에서 테스트한 결과를 취합해야 한다. 예를 들어 고성능 데스크탑의 크롬과 스마트폰의 크롬은 성능이 당연히 차이날 수 밖에 없으며, 배터리가 100%인 스마트폰과 2%인 스마트폰이 같은 성능을 보일 순 없다.
</p>

<p>
    다수의 환경에서 X가 Y보다 빠르다고 결론을 내리려면 다양한 환경에서 테스트해야 한다. 크롬에서 빠르다고 다른 브라우저에서도 빠르다고 할 수는 없으며, 때때로 실 사용자를 대상으로 멀티 브라우저 테스트한 결과를 상호 참조해야 할 수도 있다.
</p>

<p>
    jsPerf가 이러한 목적으로 개발된 웹 사이트로, 접속 가능한 공개 URL에 대하여 Benchmark.js 라이브러리를 이용하여 통계적으로 정확하고 믿음성 있는 테스트를 대행한다. 테스트를 할 때마다 결과를 수집/저장하고 다른 사람도 볼 수 있도록 누적 테스트 결과를 그래프로 보여준다.
</p>

#### 정상 테스트

```javascript
// 케이스 1
var x = [];
for (var i = 0; i < 10; i++) {
    x[i] = "x";
}

// 케이스 2
var x = [];
for (var i = 0; i < 10; i++) {
    x[x.length] = "x";
}

// 케이스 3
var x = [];
for (var i = 0; i < 10; i++) {
    x.push("x");
}
```

- 위와 같은 테스트 시나리오가 있을 때 따져봐야 할 항목
  - Benchmark.js가 필요 시 반복을 대신하며, 루프를 직접 넣을 필요는 없다.
  - 테스트 케이스마다 x를 선언/초기화할 필요는 없다.
  - 위의 테스트는 `x.length`, `x.push`가 배열에 원소를 추가할 때 성능에 얼마나 영향을 끼치는지 알아내는 테스트이며, `push()`는 함수 호출이므로 케이스 1, 2가 3보다는 빠를 것이다.

### 4. 좋은 테스트를 작성하려면

<p>
    좋은 테스트를 작성하고 싶다면 두 테스트 케이스 사이의 차이점은 무엇인지, 그 차이점은 의도적인지(Intentional) 비의도적인지(Unintentional)를 분석해야 한다. 의도적인 차이는 아무 문제가 없지만, 비의도적인 차이는 쉽게 발생하고 테스트 결과를 왜곡한다. 의도한 차이가 다른 사람들 눈에는 명확하지 않아 테스트 자체를 부정확한 것으로 의심하게 만들 수 있다.
</p>

<p>
    이를 위해서는 더 명확한 테스트를 작성해야 한다. 정확한 테스트 의도가 무엇인지 미묘한 세부분까지 문서화해야 한다. 나중에 다른 사람들 또는 스스로가 비의도적인 차이를 식별하는 데 도움이 된다.
</p>

<p>
    테스트와 크게 상관없는 부분은 페이지나 테스트 설정부에 미리 선언하는 형태로 따로 빼내어 테스트에 포함시키지 않는다.
</p>

<p>
    사소한 코드 조각에 집착하여 콘텍스트를 벗어나 한정적인 벤치마킹을 하기보다 더 넓은 범위의 콘텍스트로 포괄하면 더 나은 테스트/벤치마크를 할 수 있다. 이렇게 테스트하면 실행은 대개 더 느려지겠지만 콘텍스트와 더 밀접하게 연관된 차이점을 포착할 수 있다.
</p>

### 5. 미시성능

<p>
    자신이 작성한 코드와 실제로 엔진이 실행하는 코드가 같지 않을 수 있다. 컴파일러가 문의 위치를 재배치할 때 순서뿐 아니라 개발자 코드와 전혀 내용이 다른 코드를 실행하는 경우가 있을 수 있다.
</p>

```javascript
var foo = 41;

(function() {
    (function() {
        (function(baz) {
            var bar = foo + baz;
            // ...
        })(1);
    })();
})();
```

<p>
    위의 코드는 가장 함수에서 foo 레퍼런스는 3단계 스코프 룩업을 하여 값을 참조할 것처럼 보인다. 컴파일러는 보통 룩업을 캐시하기 때문에 다른 스코프에서 foo를 참조하더라도 실제로 추가 비용이 발생하지 않는다. 하지만 foo가 참조할 코드가 사실 한 군데 밖에 없고 그나마 그 값이 상수 41이라면 컴파일러가 그 자리를 상수로 대체할 수도 있다.
</p>

<p>
    어떤 엔진은 소스 코드의 재귀가 루프 하나로 더 쉽게 표현된다고 판단하면 풀림 재귀(Unrolling Recursion)를 할 수도 있다. 따라서 팩토리얼 재귀 코드는 임의의 자바스크립트 엔진이 아래와 같이 해석할 수도 있다.
</p>

```javascript
function factorial(n) {
    if (n < 2) return 1;

    var res = 1;
    for(var i = n; i > 1; i--) {
        res *= i;
    }
    return res;
}

console.log(factorial(5)); // 120
```

<p>
    아래의 코드는 미시성능에 집착한 사례이다.
</p>

```javascript
var x = [..];

// 옵션 1
for (var i = 0; i < x.length; i++) {
    // ...
}

// 옵션 2
for (var i = 0; len = x.length; i < len; i++) {
    // ...
}
```

<p>
    배열 x의 크기가 순회 도중 변경될 일은 없으니 변수 len에 캐시해두면 매번 x.length에서 프로퍼티를 찾는 데 드는 비용을 아낄 수 있지 않느냐는 주장이다. 하지만 막상 옵션 1과 2의 실제 통계 수치는 전혀 상관이 없다. 오히려 v8 같은 일부 엔진에선 미리 배열 길이를 캐시하면 엔진이 자체 해결하도록 놔두는 것보다 성능이 떨어진다.
</p>

#### 똑같은 엔진은 없다

<p>
    작업에 따라 어느 정도 성능 가감은 불가피하지만 어떤 작업을 최적화 대상으로 삼을지는 엔진이 주관적으로 판단할 문제다. 모든 브라우저에서 언제나 더 빨리 실행되는 접근 방식은 찾아보기 어렵다. 다음은 v8에서 종종 언급되는 사례다.
</p>

- 함수 간에 arguments 변수를 전달하지 않는다. 누수 탓에 함수 구현체가 느려진다.
- try ... catch 구문은 함수에서 뗴어낸다. 브라우저는 try ... catch 구문이 포함된 함수를 최적화하려고 하기 때문에 이 구문을 함수에 남겨두면 주변 코드는 최적화하고 반최적화를 하여 불이익을 받을 소지가 있다.

<p>
    순전히 엔진 구현 상세에 입각해서 자바스크립트 코드를 광범위하게 성능 최적화하는 일은 조심스러울 수밖에 없으며, 특정 엔진에서 만족스러운 성능이 나오지 않는다고 작성한 코드를 굳이 뜯어고칠 필요는 없다. 또한 하나의 브라우저에서 불거진 성능 문제를 보고 다른 브라우저에서는 비최적 접근 방식을 사용하는 것은 좋지 않다. 일단 개발자 올바른 코드를 작성하고 나중에 브라우저 업데이트 시 성능 개선이 이루어지길 기대하는 것이 현실적이다.
</p>

#### 큰 그림

<p>
    미세성능보다 최적화의 큰 그림을 볼 수 있어야 한다. 이를 위해 임계 경로에서 실행되는 코드인지 먼저 확인해야 한다. 임계 경로에 있지 않은 코드면 최적화해도 별 효과가 없을 가능성이 높다.
</p>

<p>
    도날드 커누스는 "너무 이른 최적화(Premature Optimization)다"라는 말을 했다. 이 말은 비임계 경로 최적화는 만병의 근원이다는 뜻과 비슷하며, 임계 경로에 잇는 코드를 밝혀내서 이를 최적화해야 하는 것이 포인트다. 임계 경로 최적화는 비록 성과가 보잘 것 없다해도 투자한 시간이 낭비되는 법이 없지만 비임계 경로 최적화는 그 결과가 아무리 좋아도 정당화하기 어렵다.
</p>

### 6. 꼬리 호출 최적화(TCO)

<p>
    ES6부터 꼬리 호출 최적화(Tail Call Optimization)에 관한 내용이 추가되었다. 꼬리 호출은 함수 호출부가 다른 함수의 꼬리 부분에 있고 호출이 끝나면 더 이상 수행할 작업을 남기지 않는 방식이다.
</p>

```javascript
function foo(x) {
    return x;
}

function bar(y) {
    return foo(y + 1); // 꼬리 호출
}

function baz() {
    return 1 + bar(40); // 꼬리 호출 아님
}

console.log(baz()); // 42
```

<p>
    위의 코드에서 `foo(y + 1)`이 꼬리 호출이다. `foo()`가 끝나면 `bar()`도 함께 끝나고 호출의 결괏값을 반환하면 되기 때문이다. 그러나 `bar(40)`은 완료 후 그 결괏값을 `baz()`가 반환하기 전 1을 더해야 하므로 꼬리 호출이 아니다.
</p>

<p>
    새 함수를 호출하려면 스택 프레임이라는 호출 스택을 쌓기 위해 별도의 메모리 할당이 필요하다. 위의 코드에서도 `baz()`, `bar()`, `foo()` 모두 한번 호출할 때마다 스택 프레임이 소모된다. 그러나 TCO 능력을 갖춘 엔진은 `foo(y + 1)`가 꼬리 위치에서 호출된다는 사실을 알고 있어서 `bar()`가 끝난 뒤 `foo()`를 부를 때 새로운 스택 프레임을 생성하지 않고 기존 `bar()` 스택 프레임을 재사용한다. 속도도 빠르며 메모리도 덜 쓰는 효과가 있다.
</p>

<p>
    자바스크립트 세계에서 재귀는 난제다. TCO가 없다면 메모리가 바닥날 수 있어 엔진은 임의로 재귀 스택 깊이를 제한할 수밖에 없다. TCO가 있으면 메모리를 더 쓸 일이 없으니 꼬리 위치 호출에 해당하는 재귀 함수는 무제한 실행이 가능하다.
</p>

<p>
    엔진 개발자에게 일임하지 않고 ES6 명세로 TCO 구현 요건을 규정한 건 TCO가 없을 경우 실제로 자바스크립트 개발자들이 호출 스택 한계를 고민한 나머지 재귀 알고리즘을 안 쓰려고 하는 경향이 있기 때문이다.
</p>
