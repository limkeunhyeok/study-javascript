# Part 1 this와 객체 프로토타입

## Chapter 6 작동 위임

### 1. 위임 지향 디자인으로 가는 길

#### 클래스 이론

<p>
    소프트웨어 모델링이 필요한 3개의 유사한 태스크(XYZ, ABC 등)가 있다고 할 때, 클래스 기반의 디자인 설계 과정은 대략 이렇다. 우선 가장 일반적인 부모 클래스 와 유사한 태스크의 공통 작동을 정의한다. Task를 상속받은 2개의 자식 클래스 XYZ, ABC를 정의한 후 이들에 특화된 작동은 두 클래스에 각각 추가한다.
</p>

<p>
    클래스 디자인 패턴에서는 될 수 있으면 메서드를 오버라이드할 것을 권장하고 작동 추가뿐 아니라 때에 따라서 오버라이드 이전 원본 메서드를 super 키워드로 호출할 수 있게 지원한다. 공통 요소는 추상화하여 부모 클래스의 일반 메서드로 구현하고 자식 클래스는 이를 더 세분화하여 쓴다.
</p>

```javascript
class Task {
    id;

    // Task() 생성자
    Task(ID) { id = ID; }
    outputTask() { output(id); }
}

class XYZ inherits Task {
    label;

    // XYZ() 생성자
    XYZ(ID, Label) { super(ID); label = Label; }
    outputTask { super(); output(label); }
}

class ABC inherits Task {
    // ...
}
```

![1](https://user-images.githubusercontent.com/38815618/91626559-25dc4380-e9eb-11ea-8458-22c625681b9e.PNG)

<p>
    더 많은 자식 클래스 XYZ의 사본을 인스턴스화하고 그렇게 탄생한 인스턴스로 XYZ 태스크를 수행한다. 이 인스턴스는 Task의 일반 작동과 XYZ의 특수 작동 사본을 모두 포함하며, ABC 클래스의 인스턴스 역시 마찬가지다. 인스턴스가 생성되면 원하는 작동은 인스턴스에 모두 복사되어 옮겨진 상태이므로 일반적으로 오직 인스턴스와 상호 작용을 한 게 된다.
</p>

#### 위임 이론

<p>
    먼저 Task 객체를 정의하는데, 이 객체에는 다양한 태스크에서 사용할 유틸리티 메서드가 포함된 구체적인 작동이 기술된다. 태스크별 객체를 정의하여 고유한 데이터와 작동을 정의하고 Task 유틸리티 객체에 연결해 필요할 때 특정 태스크 객체가 Task에 작동을 위임하도록 작성한다.
</p>

<p>
    기본적으로 XYZ 태스크 하나를 실행하려면 2개의 형제, 동료 객체로부터 작동을 가져온다고 생각할 때, 클래스 복사를 통해 이 둘을 조합하지 않아도 각자 별개의 객체로 분리된 상태에서 필요할 때마다 XYZ 객체가 Task 객체에 작동을 위임하는 구조다.
</p>

```javascript
Task = {
    setID: function(ID) { this.id = ID },
    outputID: function() { console.log(this.id); }
};

// XYZ가 Task에 위임한다
XYZ = Object.create(Task);
XYZ.prepareTask = function(ID, Label) {
    this.setID(ID);
    this.label - Label;
};

XYZ.outputTaskDetails = function() {
    this.outputID();
    console.log(this.label);
};

// ABC = Object.create(Task);
// ABC ... = ...
```

![2](https://user-images.githubusercontent.com/38815618/91626558-2543ad00-e9eb-11ea-99e0-68d538b54d65.PNG)

<p>
    위의 예제에서 Task와 XYZ는 클래스나 함수도 아닌 평범한 객체다. XYZ는 `Object.create()` 메서드로 Task 객체에 [[Prototype]] 위임을 했다. 클래스 지향과 대비하여 작가는 위의 스타일로 작성한 코드를 OLOO(객체를 다른 객체에 연결, Objects Linked to Other Objects)라 부른다. OLOO 스타일 코드는 다음과 같은 특징을 가진다.
</p>

1. 예제 코드에서 id와 label, 두 데이터 멤버는 XYZ의 직속 프로퍼티다. 일반적으로 [[Prototype]] 위임 시 상탯값은 위임하는 쪽에 두고 위임받는 쪽에는 두지 않는다.
2. 클래스 디자인 패턴에서는 일부러 부모(Task)/자식(XYZ) 양쪽에 메서드 이름을 outputTask라고 똑같이 붙여 오버라이드를 이용했다. 작동 위임 패턴은 정반대다. 서로 다른 수준의 [[Prototype]] 연쇄에서 같은 명칭이 뒤섞이는 일은 될 수 있으면 피해야 한다. 같은 이름끼리 충돌하면 레퍼런스를 정확히 가려낼 수 없는 부자연스럽고 취약한 구문이 만들어지므로 작동 위임 패턴에서는 오버라이드하기 딱 좋은 일반적인 메서드 명칭보다는 각 객체의 작동 방식을 잘 설명하는 서술적인 명칭이 필요하다. 이렇게 해야 메서드의 이름만 봐도 어떤 작동을 하는지 그 의미가 분명해지므로 코드의 가독성과 유지 보수성이 높아진다.
3. `this.setID(ID);`는 일단 XYZ 객체 내부에서 `setID()`를 찾지만 XYZ에는 이 메서드가 존재하지 않으므로 [[Prototype]] 위임 링크가 체결된 Task로 이동하여 `setID()`를 발견한다. 그리고 암시적 호출부에 따른 this 바인딩 규칙에 따라 이미 예상한 대로 Task에서 발견한 메서드지만 `setID()` 실행 시 this는 XYZ로 바인딩 된다. 그 다음 `this.outputID()`도 마찬가지다. 즉, XYZ가 Task에 작동을 위임하므로 Task가 가진 일반적인 유틸리티 메서드는 XYZ가 얼마든지 이용할 수 있는 셈이다.

<p>
    작동 위임(Behavior Delegation)이란 찾으려는 프로퍼티/메서드 레퍼런스가 객체에 없으면 다른 객체로 수색 작업을 위임하는 것을 의미한다. 작동 위임은 강력한 디자인 패턴으로, 부모/자식 클래스, 상속, 다형성 등의 사상과는 완전히 구별된다.
</p>

##### 상호 위임(허용되지 않음)

<p>
    복수의 객체가 양방향으로 상호 위임(Mutual Delegation)을 하면 발생하는 사이클은 허용되지 않는다. 즉, [B -> A]로 링크된 상태에서 [A -> B]로 링크하려고 시도하면 에러가 난다.
</p>

<p>
    아무 데도 존재하지 않는 프로퍼티/메서드를 참조하려고 하면 분명 [[Prototype]] 순회 시 무한 루프에 빠지겠지만 모든 레퍼런스가 확실히 존재한다면 [B -> A]와 [A -> B] 양방향 위임은 가능하다. 하지만 자바스크립트 엔진 제작사 입장에서는 객체 프로퍼티를 매번 검색할 때마다 가드 체크(Guard Check)를 하여 성능 히트(Performance Hit)를 측정하는 것보다 무한 순환 참조를 확인하는 로직을 구현하는 게 성능 요건에 더 부합한다고 판단되어 결국 상호 위임은 쓸 수 없게 됐다.
</p>

##### 디버깅

```javascript
function Foo() {}
var a1 = new Foo();

a1; // Foo {}
```

<p>
    위의 코드는 전통적인 클래스 생성자 스타일의 자바스크립트 코드를 크롬 개발자 툴의 콘솔창에 입력한 결과다. 마지막 줄에서 표현식 a1을 `Foo {}`로 평가한다. 같은 코드가 파이어폭스 콘솔창에서는 `Object {}`로 표시된다. 크롬의 관점은 "{}는 Foo라고 명명된 함수가 생성한 빈 객체다"라는 것이고 파이어폭스는 "{}는 Object에 의해 일반적으로 생성된 빈 객체다"라고 바라본다.
</p>

<p>
    크롬의 내부적인 생성자명 추적 기능은 자바스크립트 명세의 요건과는 별개로 크롬 전용 확장 프로그램을 위해 의도적으로 삽입한 것이다. OLOO 스타일 코드에서 권장하는 대로 객체 생성 시 생성자를 쓰지 않으면 크롬이 내부적으로 생성자명을 추적하지 않는 객체가 생길 테고 그런 객체는 `Object {}`로 제대로 출력되어 `Object()`에 의해 생성된 객체임을 알 수 있을 것이다.
</p>

#### 멘탈 모델 비교

```javascript
function Foo(who) {
    this.me = who;
}

Foo.prototype.identify = function() {
    return "I am " + this.me;
};

function Bar(who) {
    Foo.call(this, who);
}

Bar.prototype = Object.create(Foo.prototype);

Bar.prototype.speak = function() {
    console.log("Hello, " + this.identify() + ".");
};

var b1 = new Bar("b1");
var b2 = new Bar("b2");

b1.speak(); // Hello, I am b1.
b2.speak(); // Hello, I am b2.
```

<p>
    위의 코드는 전통적인 OO 스타일로 작성한 코드다. 자식 클래스 Bar는 부모 클래스 Foo를 상속한 뒤 b1과 b2로 인스턴스화한다. 그 결과 b1은 `Bar.prototype`으로 위임되며 이는 다시 `Foo.prototype`으로 위임된다.
</p>

```javascript
Foo = {
    init: function(who) {
        this.me = who;
    },
    identify: function() {
        return "I am " + this.me;
    }
};

Bar = Object.create(Foo);

Bar.speak = function() {
    console.log("Hello, " + this.identify() + ".");
};

var b1 = Object.create(Bar);
b1.init("b1");
var b2 = Object.create(Bar);
b2.init("b2");

b1.speak(); // Hello, I am b1.
b2.speak(); // Hello, I am b2.
```

<p>
    위의 코드는 OLOO 스타일로 작성한 코드다. 앞에서 [b1 -> Bar.prototype -> Foo.prototype] 방향으로 위임한 것처럼 여기서도 [b1 -> Bar -> Foo]로 [[Prototype]] 위임을 활용하며, 새 객체는 서로 단단히 연결되어 있다. 중요한 점은 정리되고 단순해졌다는 점이다. 생성자, 프로토타입, new 호출을 하면서 클래스처럼 보이게 하려고 헷깔리기만 한 장치들을 쓰지 않고 그냥 객체를 서로 연결해 주기만 했다.
</p>
