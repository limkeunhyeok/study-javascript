# Part 2 비동기와 성능

## Chapter 4 제너레이터

### 1. 완전-실행을 타파하다

```javascript
var x = 1;

function foo() {
    x++;
    bar();
    console.log("x:", x);
}

function bar() {
    x++;
}

foo(); // x: 3
```

<p>
    선점형(Preemptive) 멀티스레드 언어라면 두 문 사이의 특정 시점에 `bar()`가 끼어들어 실행되게 할 수 있지만 자바스크립트는 선점형도, 멀티스레드형 언어도 아니다. 하지만 `foo()` 자체가 어떤 코드 부분에서 멈춤 신호를 줄 수만 있다면 이러한 끼어들기(Interruption)를 협동적(Cooperative) 형태로 나타낼 수 있다.
</p>

```javascript
// 협동적 동시성을 달성한 ES6 코드

var x = 1;

function *foo() {
    x++;
    yield;
    console.log("x:", x);
}

function bar() {
    x++;
}

var it = foo();

it.next();
console.log(x); // 2
bar();
console.log(x); // 3
it.next(); // x: 3
```

- 실행 흐름
  1. `it = foo()` 할당으로 `*foo()` 제너레이터가 실행되는 건 아니며, 제너레이터 실행을 제어할 이터레이터만 마련한다.
  2. 첫 번째 `it.next()`가 `*foo()` 제너레이터를 시작하고 `*foo()` 첫째 줄의 `x++`가 실행된다.
  3. 첫 번째 `it.next()`가 완료되는 `yield` 문에서 `*foo()`는 멈춘다.
  4. x는 2를 출력한다.
  5. `bar()`를 호출하여 x가 1 증가한다.
  6. 이 때 x는 3을 출력한다.
  7. 마지막 `it.next()` 호출부에 의해 `*foo()` 제너레이터는 전에 멈췄던 곳에서 재개되며 x값 3을 출력한다.

#### 입력과 출력

<p>
    제너레이터는 특별한 함수로, 입력을 받고 어떤 값을 반환하는 기능은 일반 함수와 같다.
</p>

```javascript
function *foo(x, y) {
    return x * y;
}

var it = foo(6, 7);

var res = it.next();
console.log(res.value); // 42
```

<p>
    제너레이터는 일반 함수와는 호출 방법이 다르다. 그래서 제너레이터를 제어하는 이터레이터 객체를 만들어 변수 it에 할당하고 `it.next()`를 해야 `*foo()` 제너레이터가 현재 위치에서 다음 yield 또는 제너레이터 끝까지 실행할 수 있다. `next()`의 결괏값은 `*foo()`가 반환한 값을 value 프로퍼티에 저장한 객체다. 즉, yield는 실행 도중에 제너레이터로부터 값을, 일종의 중간 봔환 값 형태로 돌려준다.
</p>

##### 반복 메시징

```javascript
function *foo(x) {
    var y = x * (yield);
    return y;
}

var it = foo(6);
it.next();

var res = it.next(7);
console.log(res.value);
```

- 실행 순서
  1. it에 `foo(6)`를 할당하며 인자 x에 6을 넘긴다.
  2. `it.next()`를 호출하여 `*foo()`를 시작하고, yield 표현식에서 실행을 멈추고 yield 표현식에 해당하는 결괏값을 달라고 호출부 코드에 요청한다.
  3. 다음 `it.next(7)`에서 7이 yield 표현식의 결괏값이 되도록 전달한다.
  4. 결과적으로 할당문은 `var y = 6 * 7`이 되고 `return y`하면 `it.next(7)`을 호출한 결괏값 42를 반환한다.

<p>
    바라보는 관점에서 yield 문의 개수와 `next()` 호출 횟수는 제각각이며, 일반적으로 yield 개수보다 `next()` 호출이 더 많다. 첫 번째 `next()`호출이 항상 제너레이터를 가동하여 첫 번째 yield까지 실행되기 떄문이며, 이후 `next()` 호출 시에도 마찬가지다.
</p>

```javascript
function *foo(x) {
    var y = x * (yield "hello");
    return y;
}

var it = foo(6);
var res = it.next();
console.log(res.value); // hello

res = it.next(7);
console.log(res.value); // 42
```

<p>
    yield와 `next()`는 제너레이터 실행 도중 양방향 메시징 시스템으로 가능하다. 위의 코드에서 첫 번째 `next()` 호출의 의미는 기본적으로 `*foo()` 제너레이터는 다음에 어떤 값을 줄거니라는 것으로 대답은 첫 번째 `yield "hello"`표현식이 한다. 마지막 `it.next(7)` 호출은 다음에 어떤 값을 줄지 묻는 셈인데, yield 문이 없으므로 return이 대신한다. 만일 return 문이 없다면 있다 치고 암시적으로 처리한다.
</p>

#### 다중 이터레이터

<p>
    같은 제너레이터의 인스턴스를 동시에 여러 개 실행할 수 있고 인스턴스끼리 상호 작용도 가능하다.
</p>

```javascript
function *foo() {
    var x = yield 2;
    z++;
    var y = yield(x * z);
    console.log(x, y, z);
}

var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2
var val2 = it2.next().value; // 2

val1 = it1.next(val2 * 10).value; // 40
val2 = it2.next(val1 * 5).value; // 600

it1.next(val2 / 2); // 20 300 3
it2.next(val1 / 4); // 200 10 3
```

- 처리 로직
  1. `*foo()` 인스턴스 2개를 동시에 실행하고 두 `next()` 호출 모두 `yield 2` 지점에서 2를 각각 넘겨받는다.
  2. `val2 * 10`은 (2 x 10)이고 이 값은 첫 번째 인스턴스 it1에 전달되어 x값은 20이 된다. z값은 1에서 2로 증가하고 (20 x 2)를 yield하므로 val1은 40이 된다.
  3. `val1 * 5`는 (40 x 5)이고 이 값은 두 번째 인스턴스 it2에 전달되어 x값은 200이 된다. z값은 2에서 3으로 증가하고 (200 x 3)을 yield하면 val2는 600이 된다.
  4. (val2 / 2)는 (600 / 2)이고 it1로 전달되어 y값은 300이 되고 콘솔창엔 x, y, z 값이 `20 300 3`으로 각각 표시된다.
  5. (val1 / 4)는 (40 / 4)이고 it2로 전달되어 y값은 10이 되고 콘솔창엔 `200 10 3`이 표시된다.

<p>
    일반 자바스크립트 함수들 중 하나는 다른 함수보다 먼저 완전-실행될 것이다. 하지만 한 함수의 개별 문을 다른 함수에 인터리빙하여 실행하는 건 불가능하다. 반면에 제너레이터는 문 사이에서도 인터리빙할 수 있다.
</p>

```javascript
var a = 1;
var b = 2;

function *foo() {
    a++;
    yield;
    b = b * a;
    a = (yield b) + 3;
}

function *bar() {
    b--;
    yield;
    a = (yield 8) + b;
    b = a * (yield 2);
}
```

<p>
    위의 코드에서 `*foo()`, `*bar()`를 제어하는 이터레이터 호출 순서에 따라 실행 결과는 제각각일 수 있다. 즉, 같은 변수를 공유한 상태에서 두 제너레이터의 이터레이터를 인터리빙함으로써 이론적 스레드 경합 조건이 발생하는 환경을 실제로 재현할 수 있다.
</p>

### 2. 값을 제너레이터링

#### 제조기와 이터레이터

<p>
    수열같은 값이 모두 자신의 앞의 값과 어떤 관계가 분명히 정의된 일련의 값들을 생산하려고 할 때, 가장 마지막에 생산한 값을 기억하는 상태성 생산기가 필요하다. 이는 아래와 같이 함수 클로저로 구현하면 가장 직관적이다.
</p>

```javascript
var gimmeSomething = (function() {
    var nextVal;

    return function() {
        if (nextVal === undefined) {
            nextVal = 1;
        } else {
            nextVal = (3 * nextVal) + 6;
        }
        return nextVal;
    };
})();

gimmeSomething(); // 1
gimmeSomething(); // 9
gimmeSomething(); // 33
gimmeSomething(); // 105
```

<p>
    이런 작업들은 이터레이터로 해결 가능한, 일반적인 설계 패턴이다. 이터레이터는 생산자로부터 일련의 값들을 받아 하나씩 거치기 위한, 명확한(Well-Defind) 인터페이스다. 대다수의 다른 언어처럼 자바스크립트에서도 이터레이터 인터페이스는 생산기에서 다음 값이 필요할 때마다 `next()`를 호출한다.
</p>

```javascript
var something = (function() {
    var nextVal;

    return {
        // for ... of 루프에서 필요하다
        [Symbol.iterator]: function() { return this; },

        // 표준 이터레이터 인터페이스 메서드
        next: function() {
            if (nextVal === undefined) {
                nextVal = 1;
            } else {
                nextVal = (3 * nextVal) + 6;
            }
            return { done: false, value: nextVal}
        }
    };
})();

something.next().value; // 1
something.next().value; // 9
something.next().value; // 33
something.next().value; // 105
```

<p>
    `next()`를 호출하면 프로퍼티가 2개인 객체가 반환된다. done은 이터레이터 완료 상태를 가리키는 불리언 값이고 value는 순회값이다. ES6는 `for ... of` 루프를 지원하여 표준 이터레이터를 자동으로 기존 루프 구문 형태로 쓸 수 있다.
</p>

```javascript
for (var v of something) {
    console.log(v);

    if (v > 500) {
        break
    }
}
// 1 9 33 105 321 969
```

<p>
    `for ... of` 루프는 매번 자동으로 `next()`를 호출하다가 `done:true`를 받으면 그 자리에서 멈춘다. 이 방법외에도 이터레이터를 직접 수동 순회하면서 `next()`를 호출 후 `done:true` 여부 체크로 중단 시점을 판단할 수도 있다. ES6부터 배열 같은 자바스크립트 내장 자료 구조 대부분에는 기본 이터레이터가 장착되어 있다.
</p>

#### 이터러블

<p>
    `next()` 메서드로 인터페이스하는 객체를 이터레이터라고 한다. 그러나 순회 가능한 이터레이터를 포괄한 객체, 이터러블이 더 밀접한 용어다. ES6부터 이터러블은 특별한 ES6 심볼값 `Symbol.iterator`라는 이름을 가진 함수를 지니고 있어야 이 함수를 호출하여 이터러블에서 이터레이터를 가져올 수 있다. 필수 요건은 아니지만 일반적으로 함수를 호출할 때마다 새 이터레이터를 내어준다.
</p>

```javascript
[Symbol.iterator]: function() { return this; }
```

<p>
    앞선 코드에서 something 값을 이터러블로 만드는 코드로, 이제 something은 이터러블이면서 동시에 이터레이터다. 그리고 `for ... of` 루프에 something을 넘긴다.
</p>

```javascript
for(var v of something) {
    ...
}
```

<p>
    `for ... of` 루프 구문은 something이 이터러블이라는 전제하에 `Symbol.iterator` 함수가 있는지 찾아보고 호출한다. 이 함수는 그냥 `return this`하여 스스로를 돌려주기 떄문에 `for ... of` 루프는 내부 사정을 알 수 없다.
</p>

#### 제너레이터 이터레이터

<p>
    제너레이터는 일종의 값을 생산하는 공장이며, 이렇게 만들어진 값들은 이터레이터 인터페이스의 `next()`를 호출하여 한번에 하나씩 추출할 수 있다. 따라서 제너레이터 자체는 이터러블이 아니지만 흡사해서 제너레이터를 실행하면 이터레이터를 돌려받게 된다. 그러므로 앞선 수열 생산기를 아래와 같이 구현할 수 있다.
</p>

```javascript
function *something() {
    var nextVal;

    while (true) {
        if (nextVal === undefined) {
            nextVal += 1;
        } else {
            nextVal = (3 * nextVal) + 6;
        }

        yield nextVal;
    }
}
```

<p>
    제너레이터는 yield를 만나면 일단 멈추기 때문에 `function *something()`의 상태는 그대로 유지된다. 다시 말해, 호출할 때마다 변수 상탯값을 보존하기 위해 습관적으로 클로저 구문을 남발할 필요가 없다. 개발자가 직접 이터레이터 인터페이스를 작성할 필요가 없으므로 단순할 뿐만 아니라 사실 내용을 더 분명하게 표현한 추론적인(Reason-Able) 코드다.
</p>

```javascript
for (var v of something()) {
    console.log(v);
    if (v > 500) {
        break;
    }
}
// 1
// 9
// 33
// 105
// 321
// 969
```

<p>
    something을 어떤 값으로 참조한 게 아니라 `*something()` 제너레이터를 호출해서 `for ... of` 루프가 사용할 이터레이터를 얻는다. 그런데 제너레이터와 루프 간의 상호 작용에 관해서 두 가지 의문점이 생긴다.
</p>

- `for (var v of something)`처럼 쓰면 어떻게 될까?
  - something은 제너레이터지 이터러블이 아니므로 `something()`을 호출해서 `for ... of` 루프가 순회할 생산기를 만들어야 한다.
- `something()`을 호출하면 이터레이터가 만들어지지만 정작 `for ... of` 루프가 원하는 건 이터러블 아닌가?
  - 제너레이터의 이터레이터도 `Symbol.iterator` 함수가 있고 기본적으로 `return this`를 한다.

<p>
    제너레이터의 이터레이터 인터페이스는 루프 내에서 break를 호출한 이후엔 영원히 정지(Suspended) 상태가 될 것 같아 보인다. 하지만 일반적으로 break, return 또는 잡히지 않은 예외로 인해 `for ... of` 루프가 비정상 완료(Abnormal Completion)되면 제너레이터의 이터레이터를 중지하도록 신호를 준다.
</p>

<p>
    `for ... of` 루프가 자동으로 전송하는 신호를 수동으로 이터레이터에 보내야 할 경우도 있다. 이럴 때 return을 호출한다. 제너레이터가 외부적으로 완료된 다음에도 내부에서 `try ... finally` 절을 사용하면 실행할 수 있다. 이는 자원을 정리할 때 유용한 기법이다.
</p>

```javascript
function *something() {
    try {
        var nextVal;

        while (true) {
            if (nextVal === undefined) {
                nextVal = 1;
            } else {
                nextVal = (3 * nextVal) + 6;
            }
            yield nextVal;
        }
    }
    finally {
        console.log("정리 완료");
    }
}

var it = something();

for (var v of it) {
    console.log(v);

    if (v > 500) {
        console.log(it.return("hello world!").value);
        // break 문은 필요없다
    };
}
// 1
// 9
// 33
// 105
// 321
// 969
// 정리 완료
// hello world!
```

<p>
    `it.return()`하면 제너레이터 실행은 즉시 끝나고 finally 절로 옮겨간다. 또 return에 전달한 인자값이 반환 값이 되어 'hello world!'가 나온다. 제너레이터의 이터레이터는 이미 `done:true`이므로 break 문을 넣지 않아도 되며 `for ... of` 루프는 다음 순회를 끝으로 막을 내린다.
</p>

### 3. 제너레이터를 비동기적으로 순회

```javascript
// 콜백식 코드
function foo(x, y, cb) {
    ajax(
        "http://some.url.1/?x=" + x + "&y=" + y,
        cb
    );
}

foo(11, 31, function(err, text) {
    if (err) {
        console.error(err);
    } else {
        console.log(text);
    }
});
```

```javascript
// 위의 코드를 제너레이터로 표현
function foo(x, y) {
    ajax(
        "http://some.url.1/?x=" + x + "&y=" + y,
        function(err, data) {
            if (err) {
                it.throw(err);
            } else {
                it.next(data);
            }
        }
    );
}

function *main() {
    try {
        var text = yield foo(11, 31);
        console.log(text);
    } catch (err) {
        console.error(err);
    }
}

var it = main();
it.next(); // 시작!
```

<p>
    겉으로 봐선 중단적/동기적인 코드인데 실제로 전체 프로그램을 중단시키지 않으며, 제너레이터가 스스로 코드를 멈춤/중단한다. `yield foo(11, 31)`에서 `foo(11, 31)` 호출이 일어나고 반환 값은 없으므로 data를 요청하기 위해 호출을 했지만 실제로는 `yield undefined`를 수행한 셈이다. 여기서 yield는 메시지 전달 수단이 아닌 멈춤/중단을 위한 흐름 제어 수단으로 사용한 것이다. 실제로는 제너레이터가 다시 시작한 이후로 메시지 전달은 단방향으로만 이루어진다.
</p>

<p>
    AJAX 요청이 성공하면 `it.next(data);`가 실행된다. 응답 데이터 수신과 동시에 제너레이터는 재개되고 좀 전에 멈췄던 yield 표현식은 이 응답 데이터로 즉시 채워진다. 그 뒤, 제너레이터 코드를 다시 시작하면서 이 값은 지역 변수 text에 할당된다.
</p>

<p>
    제너레이터 내부의 코드는 동기적으로 작동할 것 같지만 완전히 비동기적으로 작동 가능하며, 비동기성을 순차적/동기적 방향으로 표현할 수 없었던, 콜백의 단점을 거의 보완한 솔루션이다. 본질적으로 비동기성을 하나의 구현 상세로 추상화했기 때문에 개발자가 동기/순차적으로 흐름 제어를 추론할 수 있다.
</p>

#### 동기적 에러 처리

<p>
    `try ... catch`는 프로미스에서 비동기 에러를 잡을 수 없다. 하지만 앞선 코드에서 yield로 제너레이터가 에러를 잡을 수 있게 잠시 멈추게 할 수도 있다.
</p>

```javascript
if (err) {
    it.throw(err);
}
```

<p>
    이러한 제너레이터의 yield 멈춤 기능은 비동기 함수 호출로부터 넘겨받은 값을 동기적인 형태로 return하게 해줄 뿐만 아니라 비동기 함수 실행 중 발생한 에러를 동기적으로 catch 할 수 있게도 해준다.
</p>

```javascript
function *main() {
    var x = yield "hello world!";

    // 실행되지 않음
    console.log(x);
}

var it = main();
it.next();

try {
    it.throw("???");
} catch (error) {
    console.log(error);
}

// ???
```

<p>
    제너레이터에 `throw()`로 던져넣은 해당 에러를 잡는 것도 가능해서 1차적으로는 제너레이터가 에러를 처리하겠지만 그렇지 못할 경우엔 2차적으로 이터레이터 코드가 필히 처리해야 한다. 비동기 코드에서 난 에러를 동기적인 모양새로 처리할 수 있다는 것은 코드 가독성, 추론성 면에서 매우 큰 강점이다.
</p>

### 4. 제너레이터 + 프로미스

<p>
    이터레이터는 프로미스가 귀결이 되기를 리스닝하고 있다가 제너레이터를 이룸 메시지로 재개하든지 아니면 제너레이터로 버림 사유로 채워진 에러를 던진다. 프로미스, 제너레이터를 최대한 활용하는 가장 자연스러운 방법은 우선 프로미스를 yield한 다음 이 프로미스로 제너레이터의 이터레이터를 제어하는 것이다.
</p>

```javascript
function foo(x, y) {
    return request("http://some.url.1/?x" + x + "&y=" + y);
}

function *main() {
    try {
        var text = yield foo(11, 31);
        console.log(text);
    } catch (error) {
        console.error(error);
    }
}

var it = main();
var p = it.next().value;

p.then(
    function(text) {
        it.next(text);
    },
    function(err) {
        it.throw(err);
    }
);
```

<p>
    제너레이터 이면에서 값을 yield하고 내보내는 건 구현 상세 로직이므로 어떤 일들이 일어나는지 관심가질 필요가 없다. 위의 코드는 에러 우선 콜백 방식으로 제너레이터를 수동으로 제어한 것과 비슷하다. `if (err) { it.throw ...` 대신 프로미스는 이미 이룸과 버림을 분기해주지만 이터레이터를 제어하는 부분은 똑같다.
</p>

#### 프로미스-인식형 제너레이터 실행기

```javascript
// run()을 호출하는 독자적인 Standalone 유틸리티

function run(gen) {
    var args = [].slice.call(arguments, 1), it;

    // 현재 콘텍스트에서 제너레이터를 초기화한다.
    it = gen.apply(this, args);

    // 제너레이터 완료를 의미하는 프로미스를 반환한다.
    return Promise.resolve()
        .then(function handleNext(value) {
            // 다음 yield된 값까지 실행한다.
            var next = it.next(value);

            return (function handleResult(next) {
                // 제너레이터 실행이 끝났다면,
                if (next.done) {
                    return next.value;
                // 아니면 계속 실행한다.
                } else {
                    return Promise.resolve(next.value)
                        .then(
                            // 성공 시 귀결 값을 제너레이터로 반환하면서
                            // 비동기 루프를 재개한다.
                            handleNext,

                            // value가 버림 프로미스면
                            // 제너레이터 자신이 에러를 처리하게끔
                            // 거꾸로 에러를 전파한다.
                            function handleErr(err) {
                                return Promise.resolve(
                                    it.throw(err)
                                )
                                .then(handleResult);
                            }
                        );
                }
            })(next);
        });
}

function *main() {
    // ...
}

run(main);
```

<p>
    `run()` 내부 로직에 따라 주어진 제너레이터를 비동기적으로 완료될 떄까지 알아서 진행한다.
</p>

#### 제너레이터에서의 프로미스 동시성

```javascript
function *foo() {
    var r1 = yield request("http://some.url.1");
    var r2 = yield request("http://some.url.2");

    var r3 = yield request("http://some.url.3/?v=" + r1 + "," + r2);

    console.log(r3);
}
// 앞서 정의한 run 유틸리티
run(foo);
```

<p>
    위의 코드는 잘 실행되지만 최적은 아니다. 여기서 r1, r2는 동시 실행이 가능하지만 실제로는 순차 실행된다. 두 요청은 서로 독립적이어서 가급적 동시 실행을 하는 편이 성능상 유리하다. yield는 코드 한 곳에서 멈추게 할 수는 있지만 동시에 두 곳에서 멈추게 하는 건 불가능하다. 효과적인 해결책은 전체 비동기 흐름의 기반을 프로미스에 두는, 시간 독립적 형태로 상태 관리가 가능한 프로미스 본연의 능력에 맡기는 것이다.
</p>

```javascript
function *foo() {
    // 두 요청을 병렬 실행한다.
    var p1 = request("http://some.url.1");
    var p2 = request("http://some.url.2");

    // 두 프로미스가 모두 귀결될 때까지 기다린다.
    var r1 = yield p1;
    var r2 = yield p2;

    var r3 = yield request("http://some.url.3/?v=" + r1 + "," + r2);

    console.log(r3);
}
// 앞서 정의한 run 유틸리티
run(foo);
```

<p>
    p1, p2는 동시에 AJAX를 요청하는 프로미스고 프로미스는 한번 귀결되면 귀결 상태를 계속 유지하므로 어느 요청이 먼저 완료되어도 상관없다. 그다음 있따른 yield 문 2개로 프로미스 귀결 값을 받을 때까지 대기한다. p1이 먼저 귀결되면 `yield p1`을 먼저 재개한 뒤 `yield p2` 재개를 기다린다. p2가 먼저 귀결되면 요청받을 때까지 꿋꿋이 귀결 값을 들고 있지만 `yield p1`은 p1이 귀결될 때까지 우선 보류된다. 어떻게 흘러가든 p1, p2 동시에 실행되고 순서에 상관없이 둘 다 끝나면 그제서야 r3 AJAX 요청으로 넘어간다. 이는 `Promise.all([])`로 구현한 관문 패턴과 같은 형태이다.
</p>

##### 프로미스 숨김

```javascript
// 제너레이터 아닌 일반 함수다.
function bar(url1, url2) {
    return Promise.all([
        request(url1),
        request(url2)
    ]);
}

function *foo() {
    // 프로미스형 동시성 관련 세부분은 감춘다.
    // bar() 내부
    var results = yield bar(
        "http://some.url.1",
        "http://some.url.2"
    );

    var r1 = results[0];
    var r2 = results[1];

    var r3 = yield request("http://some.url.3/?v=" + r1 + "," + r2);

    console.log(r3);
}
// 앞서 정의한 run 유틸리티
run(foo);
```

<p>
    `*foo()`가 내부적으로 `bar()`에게 어떤 결과를 요청한 뒤 yield로 기다리게 하면 코드가 훨씬 깔끔해진다. 그 과정에서 프로미스 조합을 이용하는 `Promise.all([])`의 내부에서 벌어지는 일들은 신경쓸 필요가 없다. 프로밋스 로직을 어떤 함수 안에 감추고 이 함수를 제너레이터에서 그냥 호출하는 식으로 코드를 작성하는 것은 흐름 제어를 정교하게 다루어야 할 때 특히 유용하다.
</p>

```javascript
function bar() {
    Promise.all([
        baz(..)
        .then(..),
        Promise.race([..])
    ])
    .then(..)
}
```

<p>
    위의 코드처럼 필수 로직을 제너레이터 안으로 모두 작성하는 건 일단 제너레이터를 사용하는 이유를 무의미하게 만든다. 세부 로직은 반드시 제너레이터 코드로부터 떨어뜨리고 의도적으로 추상화시켜 놓아야 상위 수준의 작업을 표현하기가 편하다.
</p>
