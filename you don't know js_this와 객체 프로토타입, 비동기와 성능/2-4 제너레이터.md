# Part 2 비동기와 성능

## Chapter 4 제너레이터

### 1. 완전-실행을 타파하다

```javascript
var x = 1;

function foo() {
    x++;
    bar();
    console.log("x:", x);
}

function bar() {
    x++;
}

foo(); // x: 3
```

<p>
    선점형(Preemptive) 멀티스레드 언어라면 두 문 사이의 특정 시점에 `bar()`가 끼어들어 실행되게 할 수 있지만 자바스크립트는 선점형도, 멀티스레드형 언어도 아니다. 하지만 `foo()` 자체가 어떤 코드 부분에서 멈춤 신호를 줄 수만 있다면 이러한 끼어들기(Interruption)를 협동적(Cooperative) 형태로 나타낼 수 있다.
</p>

```javascript
// 협동적 동시성을 달성한 ES6 코드

var x = 1;

function *foo() {
    x++;
    yield;
    console.log("x:", x);
}

function bar() {
    x++;
}

var it = foo();

it.next();
console.log(x); // 2
bar();
console.log(x); // 3
it.next(); // x: 3
```

- 실행 흐름
  1. `it = foo()` 할당으로 `*foo()` 제너레이터가 실행되는 건 아니며, 제너레이터 실행을 제어할 이터레이터만 마련한다.
  2. 첫 번째 `it.next()`가 `*foo()` 제너레이터를 시작하고 `*foo()` 첫째 줄의 `x++`가 실행된다.
  3. 첫 번째 `it.next()`가 완료되는 `yield` 문에서 `*foo()`는 멈춘다.
  4. x는 2를 출력한다.
  5. `bar()`를 호출하여 x가 1 증가한다.
  6. 이 때 x는 3을 출력한다.
  7. 마지막 `it.next()` 호출부에 의해 `*foo()` 제너레이터는 전에 멈췄던 곳에서 재개되며 x값 3을 출력한다.

#### 입력과 출력

<p>
    제너레이터는 특별한 함수로, 입력을 받고 어떤 값을 반환하는 기능은 일반 함수와 같다.
</p>

```javascript
function *foo(x, y) {
    return x * y;
}

var it = foo(6, 7);

var res = it.next();
console.log(res.value); // 42
```

<p>
    제너레이터는 일반 함수와는 호출 방법이 다르다. 그래서 제너레이터를 제어하는 이터레이터 객체를 만들어 변수 it에 할당하고 `it.next()`를 해야 `*foo()` 제너레이터가 현재 위치에서 다음 yield 또는 제너레이터 끝까지 실행할 수 있다. `next()`의 결괏값은 `*foo()`가 반환한 값을 value 프로퍼티에 저장한 객체다. 즉, yield는 실행 도중에 제너레이터로부터 값을, 일종의 중간 봔환 값 형태로 돌려준다.
</p>

##### 반복 메시징

```javascript
function *foo(x) {
    var y = x * (yield);
    return y;
}

var it = foo(6);
it.next();

var res = it.next(7);
console.log(res.value);
```

- 실행 순서
  1. it에 `foo(6)`를 할당하며 인자 x에 6을 넘긴다.
  2. `it.next()`를 호출하여 `*foo()`를 시작하고, yield 표현식에서 실행을 멈추고 yield 표현식에 해당하는 결괏값을 달라고 호출부 코드에 요청한다.
  3. 다음 `it.next(7)`에서 7이 yield 표현식의 결괏값이 되도록 전달한다.
  4. 결과적으로 할당문은 `var y = 6 * 7`이 되고 `return y`하면 `it.next(7)`을 호출한 결괏값 42를 반환한다.

<p>
    바라보는 관점에서 yield 문의 개수와 `next()` 호출 횟수는 제각각이며, 일반적으로 yield 개수보다 `next()` 호출이 더 많다. 첫 번째 `next()`호출이 항상 제너레이터를 가동하여 첫 번째 yield까지 실행되기 떄문이며, 이후 `next()` 호출 시에도 마찬가지다.
</p>

```javascript
function *foo(x) {
    var y = x * (yield "hello");
    return y;
}

var it = foo(6);
var res = it.next();
console.log(res.value); // hello

res = it.next(7);
console.log(res.value); // 42
```

<p>
    yield와 `next()`는 제너레이터 실행 도중 양방향 메시징 시스템으로 가능하다. 위의 코드에서 첫 번째 `next()` 호출의 의미는 기본적으로 `*foo()` 제너레이터는 다음에 어떤 값을 줄거니라는 것으로 대답은 첫 번째 `yield "hello"`표현식이 한다. 마지막 `it.next(7)` 호출은 다음에 어떤 값을 줄지 묻는 셈인데, yield 문이 없으므로 return이 대신한다. 만일 return 문이 없다면 있다 치고 암시적으로 처리한다.
</p>

#### 다중 이터레이터

<p>
    같은 제너레이터의 인스턴스를 동시에 여러 개 실행할 수 있고 인스턴스끼리 상호 작용도 가능하다.
</p>

```javascript
function *foo() {
    var x = yield 2;
    z++;
    var y = yield(x * z);
    console.log(x, y, z);
}

var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2
var val2 = it2.next().value; // 2

val1 = it1.next(val2 * 10).value; // 40
val2 = it2.next(val1 * 5).value; // 600

it1.next(val2 / 2); // 20 300 3
it2.next(val1 / 4); // 200 10 3
```

- 처리 로직
  1. `*foo()` 인스턴스 2개를 동시에 실행하고 두 `next()` 호출 모두 `yield 2` 지점에서 2를 각각 넘겨받는다.
  2. `val2 * 10`은 (2 x 10)이고 이 값은 첫 번째 인스턴스 it1에 전달되어 x값은 20이 된다. z값은 1에서 2로 증가하고 (20 x 2)를 yield하므로 val1은 40이 된다.
  3. `val1 * 5`는 (40 x 5)이고 이 값은 두 번째 인스턴스 it2에 전달되어 x값은 200이 된다. z값은 2에서 3으로 증가하고 (200 x 3)을 yield하면 val2는 600이 된다.
  4. (val2 / 2)는 (600 / 2)이고 it1로 전달되어 y값은 300이 되고 콘솔창엔 x, y, z 값이 `20 300 3`으로 각각 표시된다.
  5. (val1 / 4)는 (40 / 4)이고 it2로 전달되어 y값은 10이 되고 콘솔창엔 `200 10 3`이 표시된다.

<p>
    일반 자바스크립트 함수들 중 하나는 다른 함수보다 먼저 완전-실행될 것이다. 하지만 한 함수의 개별 문을 다른 함수에 인터리빙하여 실행하는 건 불가능하다. 반면에 제너레이터는 문 사이에서도 인터리빙할 수 있다.
</p>

```javascript
var a = 1;
var b = 2;

function *foo() {
    a++;
    yield;
    b = b * a;
    a = (yield b) + 3;
}

function *bar() {
    b--;
    yield;
    a = (yield 8) + b;
    b = a * (yield 2);
}
```

<p>
    위의 코드에서 `*foo()`, `*bar()`를 제어하는 이터레이터 호출 순서에 따라 실행 결과는 제각각일 수 있다. 즉, 같은 변수를 공유한 상태에서 두 제너레이터의 이터레이터를 인터리빙함으로써 이론적 스레드 경합 조건이 발생하는 환경을 실제로 재현할 수 있다.
</p>

### 2. 값을 제너레이터링

#### 제조기와 이터레이터

<p>
    수열같은 값이 모두 자신의 앞의 값과 어떤 관계가 분명히 정의된 일련의 값들을 생산하려고 할 때, 가장 마지막에 생산한 값을 기억하는 상태성 생산기가 필요하다. 이는 아래와 같이 함수 클로저로 구현하면 가장 직관적이다.
</p>

```javascript
var gimmeSomething = (function() {
    var nextVal;

    return function() {
        if (nextVal === undefined) {
            nextVal = 1;
        } else {
            nextVal = (3 * nextVal) + 6;
        }
        return nextVal;
    };
})();

gimmeSomething(); // 1
gimmeSomething(); // 9
gimmeSomething(); // 33
gimmeSomething(); // 105
```

<p>
    이런 작업들은 이터레이터로 해결 가능한, 일반적인 설계 패턴이다. 이터레이터는 생산자로부터 일련의 값들을 받아 하나씩 거치기 위한, 명확한(Well-Defind) 인터페이스다. 대다수의 다른 언어처럼 자바스크립트에서도 이터레이터 인터페이스는 생산기에서 다음 값이 필요할 때마다 `next()`를 호출한다.
</p>

```javascript
var something = (function() {
    var nextVal;

    return {
        // for ... of 루프에서 필요하다
        [Symbol.iterator]: function() { return this; },

        // 표준 이터레이터 인터페이스 메서드
        next: function() {
            if (nextVal === undefined) {
                nextVal = 1;
            } else {
                nextVal = (3 * nextVal) + 6;
            }
            return { done: false, value: nextVal}
        }
    };
})();

something.next().value; // 1
something.next().value; // 9
something.next().value; // 33
something.next().value; // 105
```

<p>
    `next()`를 호출하면 프로퍼티가 2개인 객체가 반환된다. done은 이터레이터 완료 상태를 가리키는 불리언 값이고 value는 순회값이다. ES6는 `for ... of` 루프를 지원하여 표준 이터레이터를 자동으로 기존 루프 구문 형태로 쓸 수 있다.
</p>

```javascript
for (var v of something) {
    console.log(v);

    if (v > 500) {
        break
    }
}
// 1 9 33 105 321 969
```

<p>
    `for ... of` 루프는 매번 자동으로 `next()`를 호출하다가 `done:true`를 받으면 그 자리에서 멈춘다. 이 방법외에도 이터레이터를 직접 수동 순회하면서 `next()`를 호출 후 `done:true` 여부 체크로 중단 시점을 판단할 수도 있다. ES6부터 배열 같은 자바스크립트 내장 자료 구조 대부분에는 기본 이터레이터가 장착되어 있다.
</p>

#### 이터러블

<p>
    `next()` 메서드로 인터페이스하는 객체를 이터레이터라고 한다. 그러나 순회 가능한 이터레이터를 포괄한 객체, 이터러블이 더 밀접한 용어다. ES6부터 이터러블은 특별한 ES6 심볼값 `Symbol.iterator`라는 이름을 가진 함수를 지니고 있어야 이 함수를 호출하여 이터러블에서 이터레이터를 가져올 수 있다. 필수 요건은 아니지만 일반적으로 함수를 호출할 때마다 새 이터레이터를 내어준다.
</p>

```javascript
[Symbol.iterator]: function() { return this; }
```

<p>
    앞선 코드에서 something 값을 이터러블로 만드는 코드로, 이제 something은 이터러블이면서 동시에 이터레이터다. 그리고 `for ... of` 루프에 something을 넘긴다.
</p>

```javascript
for(var v of something) {
    ...
}
```

<p>
    `for ... of` 루프 구문은 something이 이터러블이라는 전제하에 `Symbol.iterator` 함수가 있는지 찾아보고 호출한다. 이 함수는 그냥 `return this`하여 스스로를 돌려주기 떄문에 `for ... of` 루프는 내부 사정을 알 수 없다.
</p>

#### 제너레이터 이터레이터

<p>
    제너레이터는 일종의 값을 생산하는 공장이며, 이렇게 만들어진 값들은 이터레이터 인터페이스의 `next()`를 호출하여 한번에 하나씩 추출할 수 있다. 따라서 제너레이터 자체는 이터러블이 아니지만 흡사해서 제너레이터를 실행하면 이터레이터를 돌려받게 된다. 그러므로 앞선 수열 생산기를 아래와 같이 구현할 수 있다.
</p>

```javascript
function *something() {
    var nextVal;

    while (true) {
        if (nextVal === undefined) {
            nextVal += 1;
        } else {
            nextVal = (3 * nextVal) + 6;
        }

        yield nextVal;
    }
}
```

<p>
    제너레이터는 yield를 만나면 일단 멈추기 때문에 `function *something()`의 상태는 그대로 유지된다. 다시 말해, 호출할 때마다 변수 상탯값을 보존하기 위해 습관적으로 클로저 구문을 남발할 필요가 없다. 개발자가 직접 이터레이터 인터페이스를 작성할 필요가 없으므로 단순할 뿐만 아니라 사실 내용을 더 분명하게 표현한 추론적인(Reason-Able) 코드다.
</p>

```javascript
for (var v of something()) {
    console.log(v);
    if (v > 500) {
        break;
    }
}
// 1
// 9
// 33
// 105
// 321
// 969
```

<p>
    something을 어떤 값으로 참조한 게 아니라 `*something()` 제너레이터를 호출해서 `for ... of` 루프가 사용할 이터레이터를 얻는다. 그런데 제너레이터와 루프 간의 상호 작용에 관해서 두 가지 의문점이 생긴다.
</p>

- `for (var v of something)`처럼 쓰면 어떻게 될까?
  - something은 제너레이터지 이터러블이 아니므로 `something()`을 호출해서 `for ... of` 루프가 순회할 생산기를 만들어야 한다.
- `something()`을 호출하면 이터레이터가 만들어지지만 정작 `for ... of` 루프가 원하는 건 이터러블 아닌가?
  - 제너레이터의 이터레이터도 `Symbol.iterator` 함수가 있고 기본적으로 `return this`를 한다.

<p>
    제너레이터의 이터레이터 인터페이스는 루프 내에서 break를 호출한 이후엔 영원히 정지(Suspended) 상태가 될 것 같아 보인다. 하지만 일반적으로 break, return 또는 잡히지 않은 예외로 인해 `for ... of` 루프가 비정상 완료(Abnormal Completion)되면 제너레이터의 이터레이터를 중지하도록 신호를 준다.
</p>

<p>
    `for ... of` 루프가 자동으로 전송하는 신호를 수동으로 이터레이터에 보내야 할 경우도 있다. 이럴 때 return을 호출한다. 제너레이터가 외부적으로 완료된 다음에도 내부에서 `try ... finally` 절을 사용하면 실행할 수 있다. 이는 자원을 정리할 때 유용한 기법이다.
</p>

```javascript
function *something() {
    try {
        var nextVal;

        while (true) {
            if (nextVal === undefined) {
                nextVal = 1;
            } else {
                nextVal = (3 * nextVal) + 6;
            }
            yield nextVal;
        }
    }
    finally {
        console.log("정리 완료");
    }
}

var it = something();

for (var v of it) {
    console.log(v);

    if (v > 500) {
        console.log(it.return("hello world!").value);
        // break 문은 필요없다
    };
}
// 1
// 9
// 33
// 105
// 321
// 969
// 정리 완료
// hello world!
```

<p>
    `it.return()`하면 제너레이터 실행은 즉시 끝나고 finally 절로 옮겨간다. 또 return에 전달한 인자값이 반환 값이 되어 'hello world!'가 나온다. 제너레이터의 이터레이터는 이미 `done:true`이므로 break 문을 넣지 않아도 되며 `for ... of` 루프는 다음 순회를 끝으로 막을 내린다.
</p>

### 3. 제너레이터를 비동기적으로 순회

```javascript
// 콜백식 코드
function foo(x, y, cb) {
    ajax(
        "http://some.url.1/?x=" + x + "&y=" + y,
        cb
    );
}

foo(11, 31, function(err, text) {
    if (err) {
        console.error(err);
    } else {
        console.log(text);
    }
});
```

```javascript
// 위의 코드를 제너레이터로 표현
function foo(x, y) {
    ajax(
        "http://some.url.1/?x=" + x + "&y=" + y,
        function(err, data) {
            if (err) {
                it.throw(err);
            } else {
                it.next(data);
            }
        }
    );
}

function *main() {
    try {
        var text = yield foo(11, 31);
        console.log(text);
    } catch (err) {
        console.error(err);
    }
}

var it = main();
it.next(); // 시작!
```

<p>
    겉으로 봐선 중단적/동기적인 코드인데 실제로 전체 프로그램을 중단시키지 않으며, 제너레이터가 스스로 코드를 멈춤/중단한다. `yield foo(11, 31)`에서 `foo(11, 31)` 호출이 일어나고 반환 값은 없으므로 data를 요청하기 위해 호출을 했지만 실제로는 `yield undefined`를 수행한 셈이다. 여기서 yield는 메시지 전달 수단이 아닌 멈춤/중단을 위한 흐름 제어 수단으로 사용한 것이다. 실제로는 제너레이터가 다시 시작한 이후로 메시지 전달은 단방향으로만 이루어진다.
</p>

<p>
    AJAX 요청이 성공하면 `it.next(data);`가 실행된다. 응답 데이터 수신과 동시에 제너레이터는 재개되고 좀 전에 멈췄던 yield 표현식은 이 응답 데이터로 즉시 채워진다. 그 뒤, 제너레이터 코드를 다시 시작하면서 이 값은 지역 변수 text에 할당된다.
</p>

<p>
    제너레이터 내부의 코드는 동기적으로 작동할 것 같지만 완전히 비동기적으로 작동 가능하며, 비동기성을 순차적/동기적 방향으로 표현할 수 없었던, 콜백의 단점을 거의 보완한 솔루션이다. 본질적으로 비동기성을 하나의 구현 상세로 추상화했기 때문에 개발자가 동기/순차적으로 흐름 제어를 추론할 수 있다.
</p>

#### 동기적 에러 처리

<p>
    `try ... catch`는 프로미스에서 비동기 에러를 잡을 수 없다. 하지만 앞선 코드에서 yield로 제너레이터가 에러를 잡을 수 있게 잠시 멈추게 할 수도 있다.
</p>

```javascript
if (err) {
    it.throw(err);
}
```

<p>
    이러한 제너레이터의 yield 멈춤 기능은 비동기 함수 호출로부터 넘겨받은 값을 동기적인 형태로 return하게 해줄 뿐만 아니라 비동기 함수 실행 중 발생한 에러를 동기적으로 catch 할 수 있게도 해준다.
</p>

```javascript
function *main() {
    var x = yield "hello world!";

    // 실행되지 않음
    console.log(x);
}

var it = main();
it.next();

try {
    it.throw("???");
} catch (error) {
    console.log(error);
}

// ???
```

<p>
    제너레이터에 `throw()`로 던져넣은 해당 에러를 잡는 것도 가능해서 1차적으로는 제너레이터가 에러를 처리하겠지만 그렇지 못할 경우엔 2차적으로 이터레이터 코드가 필히 처리해야 한다. 비동기 코드에서 난 에러를 동기적인 모양새로 처리할 수 있다는 것은 코드 가독성, 추론성 면에서 매우 큰 강점이다.
</p>
