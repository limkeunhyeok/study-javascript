# Part 2 비동기와 성능

## Chapter 4 제너레이터

### 1. 완전-실행을 타파하다

```javascript
var x = 1;

function foo() {
    x++;
    bar();
    console.log("x:", x);
}

function bar() {
    x++;
}

foo(); // x: 3
```

<p>
    선점형(Preemptive) 멀티스레드 언어라면 두 문 사이의 특정 시점에 `bar()`가 끼어들어 실행되게 할 수 있지만 자바스크립트는 선점형도, 멀티스레드형 언어도 아니다. 하지만 `foo()` 자체가 어떤 코드 부분에서 멈춤 신호를 줄 수만 있다면 이러한 끼어들기(Interruption)를 협동적(Cooperative) 형태로 나타낼 수 있다.
</p>

```javascript
// 협동적 동시성을 달성한 ES6 코드

var x = 1;

function *foo() {
    x++;
    yield;
    console.log("x:", x);
}

function bar() {
    x++;
}

var it = foo();

it.next();
console.log(x); // 2
bar();
console.log(x); // 3
it.next(); // x: 3
```

- 실행 흐름
  1. `it = foo()` 할당으로 `*foo()` 제너레이터가 실행되는 건 아니며, 제너레이터 실행을 제어할 이터레이터만 마련한다.
  2. 첫 번째 `it.next()`가 `*foo()` 제너레이터를 시작하고 `*foo()` 첫째 줄의 `x++`가 실행된다.
  3. 첫 번째 `it.next()`가 완료되는 `yield` 문에서 `*foo()`는 멈춘다.
  4. x는 2를 출력한다.
  5. `bar()`를 호출하여 x가 1 증가한다.
  6. 이 때 x는 3을 출력한다.
  7. 마지막 `it.next()` 호출부에 의해 `*foo()` 제너레이터는 전에 멈췄던 곳에서 재개되며 x값 3을 출력한다.

#### 입력과 출력

<p>
    제너레이터는 특별한 함수로, 입력을 받고 어떤 값을 반환하는 기능은 일반 함수와 같다.
</p>

```javascript
function *foo(x, y) {
    return x * y;
}

var it = foo(6, 7);

var res = it.next();
console.log(res.value); // 42
```

<p>
    제너레이터는 일반 함수와는 호출 방법이 다르다. 그래서 제너레이터를 제어하는 이터레이터 객체를 만들어 변수 it에 할당하고 `it.next()`를 해야 `*foo()` 제너레이터가 현재 위치에서 다음 yield 또는 제너레이터 끝까지 실행할 수 있다. `next()`의 결괏값은 `*foo()`가 반환한 값을 value 프로퍼티에 저장한 객체다. 즉, yield는 실행 도중에 제너레이터로부터 값을, 일종의 중간 봔환 값 형태로 돌려준다.
</p>

##### 반복 메시징

```javascript
function *foo(x) {
    var y = x * (yield);
    return y;
}

var it = foo(6);
it.next();

var res = it.next(7);
console.log(res.value);
```

- 실행 순서
  1. it에 `foo(6)`를 할당하며 인자 x에 6을 넘긴다.
  2. `it.next()`를 호출하여 `*foo()`를 시작하고, yield 표현식에서 실행을 멈추고 yield 표현식에 해당하는 결괏값을 달라고 호출부 코드에 요청한다.
  3. 다음 `it.next(7)`에서 7이 yield 표현식의 결괏값이 되도록 전달한다.
  4. 결과적으로 할당문은 `var y = 6 * 7`이 되고 `return y`하면 `it.next(7)`을 호출한 결괏값 42를 반환한다.

<p>
    바라보는 관점에서 yield 문의 개수와 `next()` 호출 횟수는 제각각이며, 일반적으로 yield 개수보다 `next()` 호출이 더 많다. 첫 번째 `next()`호출이 항상 제너레이터를 가동하여 첫 번째 yield까지 실행되기 떄문이며, 이후 `next()` 호출 시에도 마찬가지다.
</p>

```javascript
function *foo(x) {
    var y = x * (yield "hello");
    return y;
}

var it = foo(6);
var res = it.next();
console.log(res.value); // hello

res = it.next(7);
console.log(res.value); // 42
```

<p>
    yield와 `next()`는 제너레이터 실행 도중 양방향 메시징 시스템으로 가능하다. 위의 코드에서 첫 번째 `next()` 호출의 의미는 기본적으로 `*foo()` 제너레이터는 다음에 어떤 값을 줄거니라는 것으로 대답은 첫 번째 `yield "hello"`표현식이 한다. 마지막 `it.next(7)` 호출은 다음에 어떤 값을 줄지 묻는 셈인데, yield 문이 없으므로 return이 대신한다. 만일 return 문이 없다면 있다 치고 암시적으로 처리한다.
</p>

#### 다중 이터레이터

<p>
    같은 제너레이터의 인스턴스를 동시에 여러 개 실행할 수 있고 인스턴스끼리 상호 작용도 가능하다.
</p>

```javascript
function *foo() {
    var x = yield 2;
    z++;
    var y = yield(x * z);
    console.log(x, y, z);
}

var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2
var val2 = it2.next().value; // 2

val1 = it1.next(val2 * 10).value; // 40
val2 = it2.next(val1 * 5).value; // 600

it1.next(val2 / 2); // 20 300 3
it2.next(val1 / 4); // 200 10 3
```

- 처리 로직
  1. `*foo()` 인스턴스 2개를 동시에 실행하고 두 `next()` 호출 모두 `yield 2` 지점에서 2를 각각 넘겨받는다.
  2. `val2 * 10`은 (2 x 10)이고 이 값은 첫 번째 인스턴스 it1에 전달되어 x값은 20이 된다. z값은 1에서 2로 증가하고 (20 x 2)를 yield하므로 val1은 40이 된다.
  3. `val1 * 5`는 (40 x 5)이고 이 값은 두 번째 인스턴스 it2에 전달되어 x값은 200이 된다. z값은 2에서 3으로 증가하고 (200 x 3)을 yield하면 val2는 600이 된다.
  4. (val2 / 2)는 (600 / 2)이고 it1로 전달되어 y값은 300이 되고 콘솔창엔 x, y, z 값이 `20 300 3`으로 각각 표시된다.
  5. (val1 / 4)는 (40 / 4)이고 it2로 전달되어 y값은 10이 되고 콘솔창엔 `200 10 3`이 표시된다.

<p>
    일반 자바스크립트 함수들 중 하나는 다른 함수보다 먼저 완전-실행될 것이다. 하지만 한 함수의 개별 문을 다른 함수에 인터리빙하여 실행하는 건 불가능하다. 반면에 제너레이터는 문 사이에서도 인터리빙할 수 있다.
</p>

```javascript
var a = 1;
var b = 2;

function *foo() {
    a++;
    yield;
    b = b * a;
    a = (yield b) + 3;
}

function *bar() {
    b--;
    yield;
    a = (yield 8) + b;
    b = a * (yield 2);
}
```

<p>
    위의 코드에서 `*foo()`, `*bar()`를 제어하는 이터레이터 호출 순서에 따라 실행 결과는 제각각일 수 있다. 즉, 같은 변수를 공유한 상태에서 두 제너레이터의 이터레이터를 인터리빙함으로써 이론적 스레드 경합 조건이 발생하는 환경을 실제로 재현할 수 있다.
</p>
