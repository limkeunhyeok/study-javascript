# Part 1 this와 객체 프로토타입

## Chapter 5 프로토타입

### 1. [[Prototype]]

<p>
    명세에 따르면 자바스크립트 객체는 [[Prototype]]이라는 내부 프로퍼티가 있고 다른 객체를 참조하는 단순 레퍼런스로 사용한다. 거의 모든 객체가 이 프로퍼티에 null 아닌 값이 생성 시점에 할당된다. 객체 프로퍼티 참조 시 [[Get]]이 호출된다. [[Get]]은 주어진 프로퍼티를 객체에서 찾지 못하면 [[Prototype]] 링크를 따라가면서 찾는다.
</p>

```javascript
var anotherObject = {
    a: 2
};

// anotherObject에 연결된 객체를 생성한다
var myObject = Object.create(anotherObject);

console.log(myObject) // {}
console.log(myObject.a); // 2
```

![1](https://user-images.githubusercontent.com/38815618/91215638-c0205b00-e74f-11ea-93b1-3ada3e85c37b.PNG)

<p>
    myObject는 anotherObject와 [[Prototype]]이 링크됐다. myObject.a란 프로퍼티는 없지만 anotherObject에서 2라는 값을 대신 찾아 결괏값으로 반환한다. 연쇄 끝에 이르러서도 프로퍼티가 발견되지 않으면 [[Get]]은 결괏값으로 undefined를 반환한다.
</p>

```javascript
var anotherObject = {
    a: 2
};

// anotherObject에 연결된 객체를 생성한다
var myObject = Object.create(anotherObject);

for (var k in myObject) {
    console.log(k + "를 발견!");
}

console.log("a" in myObject); // true
```

<p>
    `for ... in` 루프에서 객체를 순회할 때도 연쇄를 통해 손길이 닿는 프로퍼티라면 모두 열거한다. in 연산자로 객체에 프로퍼티 유무를 확인할 때에는 객체의 연쇄를 모두 뒤진다.
</p>

#### Object.prototype

<p>
    일반 [[prototype]] 연쇄는 결국 내장 프로토타입 Object.prototype에서 끝난다. 모든 자바스크립트 객체는 Object.prototype 객체의 자손이므로 자바스크립트에서 두루 쓰이는 다수의 공용 유틸리티가 포함되어 있다.
</p>

#### 프로퍼티 세팅과 가려짐

```javascript
myObject.foo = "bar";
```

<p>
    foo라는 이름의 평범한 데이터 접근 프로퍼티가 myObject 객체에 직속된 경우 이 할당문은 기존 프로퍼티 값을 고치는 단순한 기능을 할 뿐이다. foo가 myObject에 직속된 프로퍼티가 아니면 [[Get]]처럼 [[Prototype]] 연쇄를 순회하기 시작하고 그렇게 해도 foo가 발견되지 않으면 그제야 foo라는 프로퍼티를 myObject 객체에 추가한 후 주어진 값을 할당한다.
</p>

<p>
    foo라는 프로퍼티명이 myObject 객체와 이 객체를 기점으로 한 [[Prototype]] 연쇄의 상위 수준 두 곳에서 동시에 발견될 때 이를 가려짐(Shadowing)이라 한다. myObject에 직속한 foo 때문에 상위 연쇄의 foo가 가려지는 것이다. myObject에 직속한 foo는 없으나 myObject [[Prototype]] 연쇄의 상위 수준에 foo가 있을 때 `myObject.foo = 'bar'` 할당문의 실행 결과 다음 세 가지 경우의 수가 따른다.
</p>

1. [[Prototype]] 연쇄의 상위 수준에서 foo라는 이름의 일반 데이터 접근 프로퍼티가 존재하는데, 읽기 전용이 아닐 경우(`writable:false`), myObject의 직속 프로퍼티 foo가 새로 추가되어 결국 가려짐 프로퍼티(Shadowed Property)가 된다.
2. [[Prototype]] 연쇄의 상위 수준에서 발견한 foo가 읽기 전용(`writable:true`)이면 이 프로퍼티를 세팅하거나 myObject 객체에 가려짐 프로퍼티를 생성하는 따위의 일은 일어나지 않는다. 엄격 모드에선 에러가 나며 비엄격 모드에선 프로퍼티 세팅은 조용히 무시된다. 가려짐은 발생하지 않는다.
3. [[Prototype]] 연쇄의 상위 단계에서 발견된 foo가 세터일 경우 항상 이 세터가 호출된다. myObject에 가려짐 프로퍼티 foo를 추가하지 않으며 foo 세터를 재정의하는 일 또한 없다.

<p>
    메서드 간 위임이 필요한 상황이면 메서드 가려짐으로 인해 보기 안 좋은 명시적 의사다형성이 유발된다. 가려짐은 그 이용 가치에 비해 지나치게 복잡하고 애매한 구석이 있어 사용하지 않는 것이 좋다.
</p>

```javascript
var anotherObject = {
    a: 2
};

var myObject = Object.create(anotherObject);

console.log(anotherObject.a); // 2
console.log(myObject.a); // 2

console.log(anotherObject.hasOwnProperty("a")); // true
console.log(myObject.hasOwnProperty("a")); // false

myObject.a++; // 암시적이 가려짐이 발생한다

console.log(anotherObject.a); // 2
console.log(myObject.a); // 3

console.log(myObject.hasOwnProperty("a")); // true
```

<p>
    [[Prototype]]을 경유하여 [[Get]]을 먼저 찾고 anotherObject.a에서 현재 값 2를 얻은 뒤 1만큼 증가시킨 후, 그 결괏값 3을 다시 [[Put]]으로 myObject에 새로운 가려짐 프로퍼티 a를 생성한 뒤 할당한다.
</p>

### 2. 클래스

<p>
    자바스크립트는 여타 클래스 지향 언어에서 제공하는 클래스라는 추상회된 패턴이나 설계가 전혀 없다. 다만 객체만 있을 뿐이다. 실제로 자바스크립트는 클래스 없이 곧바로 객체를 생성할 수 있으므로 객체 지향이란 이름표가 가장 어울리는, 몇 되지 않은 프로그래밍 언어다.
</p>

#### 클래스 함수

<p>
    일종의 클래스같은 독특한 작동은 모든 함수가 기본으로 프로토타입이라는 공용(Public)/열거 불가(Nonenumerable) 프로퍼티를 가진다는 이상한 특성에 기인한다.
</p>

```javascript
function Foo() {
    // ...
}

Foo.prototype; // {}
```

<p>
    이 객체를 보통 Foo의 프로토타입이라고 하는데, 가장 직관적으로 설명하면 `new Foo()`로써 만들어진 모든 객체는 결국 Foo 점 프로토타입 객체와 [[Prototype]] 링크로 연결된다.
</p>

```javascript
function Foo() {
    // ...
}

var a = new Foo();

Object.getPrototypeOf(a) === Foo.prototype; // true
```

<p>
    `new Foo()`로 a가 생성될 때 `Foo.prototype`이 가리키는 객체를 내부 [[Prototype]]과 연결한다. 클래스 지향 언어에서는 클래스를 다중 복사(Multiple Copies)할 수 있다. 클래스 인스턴스화 자체가 클래스 작동 계획을 실제 객체로 복사하는 것이므로 인스턴스마다 복사가 일어난다.
</p>

<p>
    자바스크립트는 이런 복사 과정이 전혀 없고 클래스에서 여러 인스턴스를 생성할 수도 없다. 어떤 공용 객체에 [[Prototype]]으로 연결된 객체를 다수 생성하는 건 가능하지만 기본적으로 어떠한 복사도 일어나지 않아서 결과적으로 자바스크립트에서 객체들은 서로 완전히 떨어져 분리되는 것이 아니라 끈끈하게 연결된다.
</p>

<p>
    `new Foo()`로 새 객체 a가 만들어지고 이 객체는 `Foo.prototype` 객체와 내부적으로 [[Prototype]]과 연결이 맺어진다. 결국, 상호 연결된 두 개의 객체로 귀결된다. 사실 `new Foo()` 호출 자체는 이러한 링크의 생성 프로세스와 거의 관련이 없다. 일종의 우발적인 부수 효과다. `new Foo()`는 결국 새 색체를 다른 객체와 연결하기 위한 간접적인 우회 방법인 셈이다.
</p>

##### 이름에는 무엇이 들어 있을까

<p>
    [[Prototype]] 체계를 다른 말로 프로토타입 상속(Prototypal Inheritance)이라고 하며 흔히 클래스 상속의 동적 언어 버전이라고 한다. 클래스 지향 세상에서 지극히 일반적인 상속 개념을 잘 살려 동적 스크립트 언어에 맞게 그 의미를 조금 변형한 장치다.
</p>

<p>
    상속은 기본으로 복사를 수반하지만, 자바스크립트는 객체 프로퍼티를 복사하지 않는다. 대신 두 객체에 링크를 걸어두고 한쪽이 다른 쪽의 프로퍼티/함수에 접근할 수 있게 위임한다.
</p>

<p>
    차등 상속(Differential Inheritance)이라는 표현도 있다. 어떤 객체의 작동을 더 일반적인 객체와 비교했을 때 어느 부분이 다른지 기술하는 아이디어다. 예를 들어, 자동차는 탈것 중 하나지만 일반적인 탈것의 특성(엔진 등)을 제외하고 차이가 나는 부분(자동차 바퀴는 4개다)만 기술하는 식이다.
</p>

<p>
    프로토타입 상속, 차등 상속 등의 표현은 그럴 듯하지만 실제 자바스크립트 코드에서 벌어지는 일보다 멘탈 모델(Mental Model)을 더 중요시하는 것처럼 보인다. 이는 객체가 실제로 차등적으로 만들어지는 것이 아니라 아무것도 정의되지 않은 구덩이(Hole)와 함께 특정 속성들을 정의함으로써 생성된다는 사실을 간과한 것이다. 바로 이 구덩이를 위임이 넘겨받아 그때그때 상황에 맞게 위임받은 작동으로 채워 넣는다.
</p>
