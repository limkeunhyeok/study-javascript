# Part 2 비동기와 성능

## Chapter 3 프로미스

> 프로미스는 개발자와 명세 작성자가 함께 코딩/설계 단계에서 콜백 지옥을 해결하기 위해 등장하였다. 프로미스는 제어의 역전을 되역전시키는, 즉 프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그 다음에 무슨일을 해야 할지 스스로 결정할 수 있는 체계이다.

### 1. 프로미스란

#### 미랫값

> 만일 음식을 주문하고 결제하여 동시에 거래(Transaction)가 시작된다고 할 때, 주문이 밀리면 점원은 주문 번호가 적힌 영수증을 건네준다. 이 주문 번호는 언젠가 반드시 주문한 음식을 주겠다는 프로미스(약속)이다. 음식을 기다리면서 다른 일을 할 때, 두뇌는 영수증의 적힌 주문 번호를 음식의 자리 끼움(Placeholder)으로 인식한다. 이 자리 끼움은 시간 독립적(Time Independent)인 값, 즉 미랫값(Future Value)이다. 결국 점원은 주문 번호를 부르고, 영수증과 음식을 교환할 것이다. 미랫값이 준비되어 갖고 있던 값-프로미스(Value-Promise)를 값 자체와 교환한 셈이다. 한편 재료가 떨어져 음식을 받지 못하는 경우도 발생할 수 있다. 미랫값은 성공 아니면 실패라는 것이다.

##### 지금값과 나중값

```javascript
var x, y = 2;
console.log(x + y); // NaN <-- x는 세팅 전이다.
```

<p>
    숫자 계산 등 어떤 값을 내는 코드를 짤 때, 그 값이 지금 존재하는 구체적인 값이라는 매우 근원적인 가정을 한다. 위의 코드에서 `x + y` 연산을 할 땐 당연히 x, y 모두 이미 세팅된 값으로 보며 이미 귀결됐다(Resolved)고 할 수 있다. 하지만 + 연산자가 홀로 x, y 값의 상태를 감지하다가 모두 귀결된 후 덧셈 연산을 하지는 않는다. 상이한 문 중 어떤 문은 지금 실행되고 다른 문은 나중에 실행되면 프로그램이 혼돈에 빠진다.
</p>

```javascript
function add(getX, getY, cb) {
    var x, y;
    getX(function(xVal) {
        x = xVal;
        // 두 값이 있다면 덧셈
        if (y != undefined) {
            cb(x + y);
        }
    });
    getY(function(yVal) {
        y = yVal;
        // 두 값이 있다면 덧셈
        if (x != undefined) {
            cb(x + y);
        }
    });
}

// fetchX()와 fetchY()는 동기/비동기 함수
add(fetchX. fetchY, function(sum) {
    console.log(sum);
});
```

<p>
    위의 코드에서 x, y는 모두 미랫값으로 취급한다. 따라서 `add()` 함수 입장에서 x 또는 y의 값이 지금 준비된 상태인지는 관심 밖이다. 다시 말해 지금과 나중을 정규화(Normalize)한 결과, `add()`의 처리 결과를 예측할 수 있게 바뀐 것이다. 시간에 대해 한결같은 `add()` 덕분에 비동기 코드가 훨씬 추론하기 편해졌다. 중요한 점은 지금과 나중을 모두 일관적으로 다루려면 둘 다 나중으로 만들어 모든 작업을 비동기화하면 된다.
</p>

##### 프로미스 값

```javascript
function add(xPromimse, yPromise) {
    // Promise.all([])은 프로미스 배열을 인자로 받아
    // 프로미스들이 모두 귀결될 때까지 기다렸다가
    // 새 프로미스를 만들어 반환하는 함수다.
    return Promise.all([xPromise, yPromise])
    // 프로미스가 귀결되면 X와 Y 값을 받아 더한다.
    .then(function(values) {
        return values[0] + values[1];
    });
}

// fetchX()와 fetchY()는 제각기 값을 가진
// 프로미스를 반환하는데 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
// 두 숫자의 합이 담긴 프로미스를 받는다.
// 이제 반환된 프로미스가 귀결될 때까지 대기하기 위해
// then()을 연쇄 호출한다.
.then(function(sum) {
    console.log(sum);
});
```

<p>
    위의 코드에서 두 계층의 프로미스가 있다. `fetchX()`와 `fetchY()`를 직접 호출하여 이들의 반환 값을 `add()`에 전한다. 두 프로미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프로미스가 같은 결과를 내게끔 정규화한다. 덕분에 미랫값 X, Y는 시간 독립적으로 추론할 수 있다. 두 번째 계층은 `add()`가 만들어 반환한 프로미스로 `then()`을 호출하고 대기한다. `add()`가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 `add()` 안에 숨어있다.
</p>

<p>
    `add()`에서 `Promise.all([])`을 호출하여 프로미스를 생성한다. `.then()`을 연쇄 호출하면 또 다른 프로미스가 생성되는데, `return values[0] + values[1]` 줄은 즉시 귀결되므로 `add()` 호출 끝에서 연쇄된 `then()` 호출은 실제로 `Promise.all([])`이 생성한 첫 번째 프로미스가 아닌 `add()`가 반횐된 두 번째 프로미스에서 작동한다. 그리고 두 번째 `then()` 끝에서 더는 연쇄 호출을 하진 않았지만 `then()` 역시 프로미스를 하나 더 생성하므로 뒷부분에서 이 프로미스를 사용/감지할 수 있다.
</p>

<p>
    프로미스는 이룸(Fulfillment)아닌 버림(Rejection)으로 귀결될 수 있다. 항상 귀결 값을 프로그램이 결정짓는 이룸 프로미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 한다. 프로미스 `then()` 함수는 이룸 함수를 첫 번째 인자로, 버림 함수는 두 번째 인자로 각각 넘겨받는다.
</p>

```javascript
add(fetchX(), fetchY())
.then(
    // 이룸 함수
    function(sum) {
        console.log(sum);
    },
    // 버림 함수
    function(err) {
        console.error(err);
    }
);
```

<p>
    X와 Y 조회 시 문제가 있거나 덧셈 연산이 실패하면 `add()`가 반환하는 프로미스는 버려지고 `then()`의 두 번째 에러 처리 콜백이 프로미스에서 버림값을 받는다. 프로미스는 시간 의존적인(Time-Dependent) 상태를 외부로부터 캡슐화하기 때문에 프로미스 자체는 시간 독립적(Time-Independent)이고 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있다. 또한 프로미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있다.
</p>

<p>
    프로미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프로미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프로미스 귀결에 영향을 줄 수는 없다. 프로미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치다.
</p>

#### 완료 이벤트

<p>
    프로미스 각각은 미랫값으로서 작동하지만 프로미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계라 볼 수 있다. 어떤 작업을 하려고 `foo()` 함수를 부른다고 할 때, 단지 `foo()`가 언제 끝나 다음 단계로 넘어갈 수 있을지만 알면 된다. 전통적인 자바스크립트 사고 방식에서는 알림 자체를 하나의 이벤트로 보고 리스닝한다. `foo()`의 완료 이벤트를 리스닝 함으로써 알림 요건을 재구헝하는 것이다.
</p>

<p>
    콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성립된다. 하지만 프로미스에서는 이 관계가 역전되어 `foo()`에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행한다.
</p>

```javascript
foo(x) {
    // 제법 시간이 걸리는 작업
}

foo(42)

on(foo "완료") {
    // 다음 단계로 넘어간다
}

on(foo "에러") {
    // foo()에서 문제가 발생했다
}
```

<p>
    `foo()`를 부른 뒤 2개의 이벤트 리스너를 설정한다. `foo()`를 호출하여 나올 수 있는 결과는 완료 아니면 에러 뿐이다. 실상 `foo()`는 호출부에서 이벤트를 받아 어떻게 처리할지 알 길이 없으니 관심사가 분리(Separation of Concerns)된다. 이를 자연스런 자바스크립트 코드로 표현하면 아래와 같다.
</p>

```javascript
function foo(x) {
    // 제법 시간이 걸리는 작업
    // 이벤트 구독기를 생성하여 반환
    return listener;
}

var evt = foo(42);

evt.on("completion", function() {
    // 다음 단계로 넘어간다.
});

evt.on("failure", function(err {
    // foo()에서 문제가 발생했다.
});
```

<p>
    `foo()`는 이벤트 구독기를 생성하여 반환하도록 명시되어 있고 여기에 호출부 코드는 두 이벤트 처리기를 각각 등록한다. `foo()`에 콜백 함수를 넘겨주는 대신 `foo()`가 evt라는 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣는다. 콜백은 그 자신이 제어의 역전이다. 따라서 콜백 패턴을 뒤집는다는 건 실상 역전을 역전, 곧 제어의 되역전(Universion of Control)이고 제어권을 호출부에 되돌려놓게 된다. 이렇게 되면 여러 파트로 나뉘어진 코드가 이벤트를 리스닝하면서 `foo()` 완료 시 독립적으로 알림을 받아 이후 단계를 진행하게 된다.
</p>

```javascript
var evt = foo(42);

// bar()는 foo()의 완료 이벤트를 리스닝한다.
bar(evt);

// baz()도 foo()의 완료 이벤트를 리스닝한다.
baz(evt);
```

<p>
    제어의 비역전 덕분에 관심사를 분리하여 `bar()`, `baz()`는 `foo()` 호출에 끼어들 이유가 전혀 없어졌다. 마찬가지로 `foo()` 역시 `bar()`, `baz()`가 있거나 말거나 또는 자신이 완료되기를 누군가 기다리고 있다는 사실을 몰라도 된다. 결국 evt 객체가 분리된 관심사 간의 중립적인 중재자 역활을 수행하는 것이다.
</p>

##### 프로미스 이벤트

<p>
    리스닝 중인 프로미스 귀결 이벤트는 엄밀히 말해서 이벤트가 아니고 완료나 에러라고 하지 않는게 보통이다. 대신에 `then()`을 통한 then 이벤트의 등록이며, 이룸, 버림 이벤트를 등록하는 것이다.
</p>

```javascript
function foo(x) {
    // 제법 시간이 걸리는 작업

    // 프로미스를 생성하여 반환한다.
    return new Promise(function(resolve, reject) {
        // 결과적으로 resolve(), reject()
        // 중 한 쪽을 호출하게 되고 이들은 프로미스의
        // 귀결 콜백 함수 역활을 한다.
    });
}

var p = foo(42);

bar(p);
baz(p);
```

<p>
    `new Promise(function() {})`는 생성자 노출(Revealing Constructor) 패턴의 전형적인 모습이다. 전달된 function은 즉시 실행되고 resolve, reject라고 이름 붙인 인자 2개를 받는다. 이 두 인자가 바로 프로미스의 귀결 함수다. `resolve()`는 이룸, `reject()`은 버림을 나타낸다. `bar()`와 `baz()` 내부는 아래와 같이 구현되어 있을 것이다.
</p>

```javascript
function bar(fooPromise) {
    // foo()의 완료 여부를 리스닝한다.
    fooPromise.then(
        function() {
            // foo()는 이제 bar() 작업을 한다.
        },
        function() {
            // 에러 발생 시 실행된다.
        }
    );
}

// baz도 마찬가지
```

<p>
    프로미스를 미랫값으로 다루었을 때처럼 프로미스 귀결 시 어떤 메시지를 보내야 하는 건 아니다. 위의 코드처럼 흐름 제어 신호로 쓰일 수도 있다.
</p>

```javascript
function bar() {
    // foo()는 확실히 끝났으므로
    // bar() 작업을 한다.
}

function oopsBar() {
    // 에러가 발생되어
    // bar()는 실행되지 않는다.
}

// baz()와 oopsBaz()도 마찬가지

var p = foo(42);
p.then(bar, oopsBar);
p.then(baz, oopsBaz);
```

<p>
    프라미스 p를 `bar()`, `baz()`에 태워보내는 대신 `bar()`, `baz()` 두 함수의 실행 이후를 제어하기 위해 프로미스를 이용한다. 앞선 코드와 차이점은 에러 처리 방식이다. 전자는 `foo()`의 이룸/버림 여부와 관계없이 무조건 `bar()`를 호출하고 `foo()` 실행이 실패할 경우엔 자체 로직으로 처리한다. `baz()`도 마찬가지다. 후자는 `foo()` 성공 시에만 `bar()`를 호출하고 그 외엔 `oopsBar()`를 호출한다. `baz()`도 그렇다. 어느 것이 좋다고는 할 수는 없으며 상황에 따라 적절한 방식을 선택하면 된다. 또한, 두 예제 모두 같은 프로미스 p에 대해 `then()`을 두 번 호출하는 부분에서, 프로미스는 똑같은 결과를 유지하므로 이후에 필요하다면 몇번이고 계속 꺼내 쓸 수 있다.
</p>
