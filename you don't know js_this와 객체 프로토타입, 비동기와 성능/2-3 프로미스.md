# Part 2 비동기와 성능

## Chapter 3 프로미스

> 프로미스는 개발자와 명세 작성자가 함께 코딩/설계 단계에서 콜백 지옥을 해결하기 위해 등장하였다. 프로미스는 제어의 역전을 되역전시키는, 즉 프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그 다음에 무슨일을 해야 할지 스스로 결정할 수 있는 체계이다.

### 1. 프로미스란

#### 미랫값

> 만일 음식을 주문하고 결제하여 동시에 거래(Transaction)가 시작된다고 할 때, 주문이 밀리면 점원은 주문 번호가 적힌 영수증을 건네준다. 이 주문 번호는 언젠가 반드시 주문한 음식을 주겠다는 프로미스(약속)이다. 음식을 기다리면서 다른 일을 할 때, 두뇌는 영수증의 적힌 주문 번호를 음식의 자리 끼움(Placeholder)으로 인식한다. 이 자리 끼움은 시간 독립적(Time Independent)인 값, 즉 미랫값(Future Value)이다. 결국 점원은 주문 번호를 부르고, 영수증과 음식을 교환할 것이다. 미랫값이 준비되어 갖고 있던 값-프로미스(Value-Promise)를 값 자체와 교환한 셈이다. 한편 재료가 떨어져 음식을 받지 못하는 경우도 발생할 수 있다. 미랫값은 성공 아니면 실패라는 것이다.

##### 지금값과 나중값

```javascript
var x, y = 2;
console.log(x + y); // NaN <-- x는 세팅 전이다.
```

<p>
    숫자 계산 등 어떤 값을 내는 코드를 짤 때, 그 값이 지금 존재하는 구체적인 값이라는 매우 근원적인 가정을 한다. 위의 코드에서 `x + y` 연산을 할 땐 당연히 x, y 모두 이미 세팅된 값으로 보며 이미 귀결됐다(Resolved)고 할 수 있다. 하지만 + 연산자가 홀로 x, y 값의 상태를 감지하다가 모두 귀결된 후 덧셈 연산을 하지는 않는다. 상이한 문 중 어떤 문은 지금 실행되고 다른 문은 나중에 실행되면 프로그램이 혼돈에 빠진다.
</p>

```javascript
function add(getX, getY, cb) {
    var x, y;
    getX(function(xVal) {
        x = xVal;
        // 두 값이 있다면 덧셈
        if (y != undefined) {
            cb(x + y);
        }
    });
    getY(function(yVal) {
        y = yVal;
        // 두 값이 있다면 덧셈
        if (x != undefined) {
            cb(x + y);
        }
    });
}

// fetchX()와 fetchY()는 동기/비동기 함수
add(fetchX. fetchY, function(sum) {
    console.log(sum);
});
```

<p>
    위의 코드에서 x, y는 모두 미랫값으로 취급한다. 따라서 `add()` 함수 입장에서 x 또는 y의 값이 지금 준비된 상태인지는 관심 밖이다. 다시 말해 지금과 나중을 정규화(Normalize)한 결과, `add()`의 처리 결과를 예측할 수 있게 바뀐 것이다. 시간에 대해 한결같은 `add()` 덕분에 비동기 코드가 훨씬 추론하기 편해졌다. 중요한 점은 지금과 나중을 모두 일관적으로 다루려면 둘 다 나중으로 만들어 모든 작업을 비동기화하면 된다.
</p>

##### 프로미스 값

```javascript
function add(xPromimse, yPromise) {
    // Promise.all([])은 프로미스 배열을 인자로 받아
    // 프로미스들이 모두 귀결될 때까지 기다렸다가
    // 새 프로미스를 만들어 반환하는 함수다.
    return Promise.all([xPromise, yPromise])
    // 프로미스가 귀결되면 X와 Y 값을 받아 더한다.
    .then(function(values) {
        return values[0] + values[1];
    });
}

// fetchX()와 fetchY()는 제각기 값을 가진
// 프로미스를 반환하는데 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
// 두 숫자의 합이 담긴 프로미스를 받는다.
// 이제 반환된 프로미스가 귀결될 때까지 대기하기 위해
// then()을 연쇄 호출한다.
.then(function(sum) {
    console.log(sum);
});
```

<p>
    위의 코드에서 두 계층의 프로미스가 있다. `fetchX()`와 `fetchY()`를 직접 호출하여 이들의 반환 값을 `add()`에 전한다. 두 프로미스 속의 원래 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프로미스가 같은 결과를 내게끔 정규화한다. 덕분에 미랫값 X, Y는 시간 독립적으로 추론할 수 있다. 두 번째 계층은 `add()`가 만들어 반환한 프로미스로 `then()`을 호출하고 대기한다. `add()`가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력되는데 X, Y의 미랫값을 기다리는 로직은 `add()` 안에 숨어있다.
</p>

<p>
    `add()`에서 `Promise.all([])`을 호출하여 프로미스를 생성한다. `.then()`을 연쇄 호출하면 또 다른 프로미스가 생성되는데, `return values[0] + values[1]` 줄은 즉시 귀결되므로 `add()` 호출 끝에서 연쇄된 `then()` 호출은 실제로 `Promise.all([])`이 생성한 첫 번째 프로미스가 아닌 `add()`가 반횐된 두 번째 프로미스에서 작동한다. 그리고 두 번째 `then()` 끝에서 더는 연쇄 호출을 하진 않았지만 `then()` 역시 프로미스를 하나 더 생성하므로 뒷부분에서 이 프로미스를 사용/감지할 수 있다.
</p>

<p>
    프로미스는 이룸(Fulfillment)아닌 버림(Rejection)으로 귀결될 수 있다. 항상 귀결 값을 프로그램이 결정짓는 이룸 프로미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 한다. 프로미스 `then()` 함수는 이룸 함수를 첫 번째 인자로, 버림 함수는 두 번째 인자로 각각 넘겨받는다.
</p>

```javascript
add(fetchX(), fetchY())
.then(
    // 이룸 함수
    function(sum) {
        console.log(sum);
    },
    // 버림 함수
    function(err) {
        console.error(err);
    }
);
```

<p>
    X와 Y 조회 시 문제가 있거나 덧셈 연산이 실패하면 `add()`가 반환하는 프로미스는 버려지고 `then()`의 두 번째 에러 처리 콜백이 프로미스에서 버림값을 받는다. 프로미스는 시간 의존적인(Time-Dependent) 상태를 외부로부터 캡슐화하기 때문에 프로미스 자체는 시간 독립적(Time-Independent)이고 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있다. 또한 프로미스는 일단 귀결된 후에는 상태가 그대로 유지되며 몇 번이든 필요할 때마다 꺼내 쓸 수 있다.
</p>

<p>
    프로미스는 귀결되고 나면 외부적으로 불변 상태이므로 사고로 또는 악의적으로 변경되는 일은 없으며 안심하고 다른 파트에 전달할 수 있다. 특히 여러 파트가 프로미스 귀결 상태를 바라보고 있을 땐 더더욱 그렇다. 어느 파트가 다른 파트가 바라보고 있는 프로미스 귀결에 영향을 줄 수는 없다. 프로미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치다.
</p>

#### 완료 이벤트

<p>
    프로미스 각각은 미랫값으로서 작동하지만 프로미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계라 볼 수 있다. 어떤 작업을 하려고 `foo()` 함수를 부른다고 할 때, 단지 `foo()`가 언제 끝나 다음 단계로 넘어갈 수 있을지만 알면 된다. 전통적인 자바스크립트 사고 방식에서는 알림 자체를 하나의 이벤트로 보고 리스닝한다. `foo()`의 완료 이벤트를 리스닝 함으로써 알림 요건을 재구헝하는 것이다.
</p>

<p>
    콜백에서의 알림은 작업부에서 넘겨준 콜백을 호출하면 성립된다. 하지만 프로미스에서는 이 관계가 역전되어 `foo()`에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행한다.
</p>

```javascript
foo(x) {
    // 제법 시간이 걸리는 작업
}

foo(42)

on(foo "완료") {
    // 다음 단계로 넘어간다
}

on(foo "에러") {
    // foo()에서 문제가 발생했다
}
```

<p>
    `foo()`를 부른 뒤 2개의 이벤트 리스너를 설정한다. `foo()`를 호출하여 나올 수 있는 결과는 완료 아니면 에러 뿐이다. 실상 `foo()`는 호출부에서 이벤트를 받아 어떻게 처리할지 알 길이 없으니 관심사가 분리(Separation of Concerns)된다. 이를 자연스런 자바스크립트 코드로 표현하면 아래와 같다.
</p>

```javascript
function foo(x) {
    // 제법 시간이 걸리는 작업
    // 이벤트 구독기를 생성하여 반환
    return listener;
}

var evt = foo(42);

evt.on("completion", function() {
    // 다음 단계로 넘어간다.
});

evt.on("failure", function(err {
    // foo()에서 문제가 발생했다.
});
```

<p>
    `foo()`는 이벤트 구독기를 생성하여 반환하도록 명시되어 있고 여기에 호출부 코드는 두 이벤트 처리기를 각각 등록한다. `foo()`에 콜백 함수를 넘겨주는 대신 `foo()`가 evt라는 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣는다. 콜백은 그 자신이 제어의 역전이다. 따라서 콜백 패턴을 뒤집는다는 건 실상 역전을 역전, 곧 제어의 되역전(Universion of Control)이고 제어권을 호출부에 되돌려놓게 된다. 이렇게 되면 여러 파트로 나뉘어진 코드가 이벤트를 리스닝하면서 `foo()` 완료 시 독립적으로 알림을 받아 이후 단계를 진행하게 된다.
</p>

```javascript
var evt = foo(42);

// bar()는 foo()의 완료 이벤트를 리스닝한다.
bar(evt);

// baz()도 foo()의 완료 이벤트를 리스닝한다.
baz(evt);
```

<p>
    제어의 비역전 덕분에 관심사를 분리하여 `bar()`, `baz()`는 `foo()` 호출에 끼어들 이유가 전혀 없어졌다. 마찬가지로 `foo()` 역시 `bar()`, `baz()`가 있거나 말거나 또는 자신이 완료되기를 누군가 기다리고 있다는 사실을 몰라도 된다. 결국 evt 객체가 분리된 관심사 간의 중립적인 중재자 역활을 수행하는 것이다.
</p>

##### 프로미스 이벤트

<p>
    리스닝 중인 프로미스 귀결 이벤트는 엄밀히 말해서 이벤트가 아니고 완료나 에러라고 하지 않는게 보통이다. 대신에 `then()`을 통한 then 이벤트의 등록이며, 이룸, 버림 이벤트를 등록하는 것이다.
</p>

```javascript
function foo(x) {
    // 제법 시간이 걸리는 작업

    // 프로미스를 생성하여 반환한다.
    return new Promise(function(resolve, reject) {
        // 결과적으로 resolve(), reject()
        // 중 한 쪽을 호출하게 되고 이들은 프로미스의
        // 귀결 콜백 함수 역활을 한다.
    });
}

var p = foo(42);

bar(p);
baz(p);
```

<p>
    `new Promise(function() {})`는 생성자 노출(Revealing Constructor) 패턴의 전형적인 모습이다. 전달된 function은 즉시 실행되고 resolve, reject라고 이름 붙인 인자 2개를 받는다. 이 두 인자가 바로 프로미스의 귀결 함수다. `resolve()`는 이룸, `reject()`은 버림을 나타낸다. `bar()`와 `baz()` 내부는 아래와 같이 구현되어 있을 것이다.
</p>

```javascript
function bar(fooPromise) {
    // foo()의 완료 여부를 리스닝한다.
    fooPromise.then(
        function() {
            // foo()는 이제 bar() 작업을 한다.
        },
        function() {
            // 에러 발생 시 실행된다.
        }
    );
}

// baz도 마찬가지
```

<p>
    프로미스를 미랫값으로 다루었을 때처럼 프로미스 귀결 시 어떤 메시지를 보내야 하는 건 아니다. 위의 코드처럼 흐름 제어 신호로 쓰일 수도 있다.
</p>

```javascript
function bar() {
    // foo()는 확실히 끝났으므로
    // bar() 작업을 한다.
}

function oopsBar() {
    // 에러가 발생되어
    // bar()는 실행되지 않는다.
}

// baz()와 oopsBaz()도 마찬가지

var p = foo(42);
p.then(bar, oopsBar);
p.then(baz, oopsBaz);
```

<p>
    프라미스 p를 `bar()`, `baz()`에 태워보내는 대신 `bar()`, `baz()` 두 함수의 실행 이후를 제어하기 위해 프로미스를 이용한다. 앞선 코드와 차이점은 에러 처리 방식이다. 전자는 `foo()`의 이룸/버림 여부와 관계없이 무조건 `bar()`를 호출하고 `foo()` 실행이 실패할 경우엔 자체 로직으로 처리한다. `baz()`도 마찬가지다. 후자는 `foo()` 성공 시에만 `bar()`를 호출하고 그 외엔 `oopsBar()`를 호출한다. `baz()`도 그렇다. 어느 것이 좋다고는 할 수는 없으며 상황에 따라 적절한 방식을 선택하면 된다. 또한, 두 예제 모두 같은 프로미스 p에 대해 `then()`을 두 번 호출하는 부분에서, 프로미스는 똑같은 결과를 유지하므로 이후에 필요하다면 몇번이고 계속 꺼내 쓸 수 있다.
</p>

### 2. 데너블 덕 타이핑

<p>
    프로미스 세상에서 중요한 문제는 과연 어떤 값이 진짜 프로미스인지 아닌지 어찌 확신할 수 있는가 하는 점이다. 사실 프로미스 값은 주로 다른 브라우저 창에서 넘겨받는데, 현재 윈도우/프레임에 있는 프로미스와는 동떨어진 그들만의 프로미스이므로 프로미스 인스턴스 체크만으로는 제대로 확인할 수 없다. 또한 외부 라이브러리/프레임워크 중에는 ES6 Promise가 아닌 고유한 방법으로 구현한 프로미스를 사용할 가능성도 있다. 그리고 프로미스가 없는 구식 브라우저에서 라비으러리 형태로 프로미스를 사용하는 경우도 무시할 수 없다.
</p>

<p>
    프로미스는 `then()` 메서드를 가진 데너블(Thenable)이라는 객체 또는 함수를 정의하여 판별하는 것으로 규정됐다. 데너블에 해당하는 값은 무조건 프로미스 규칙에 맞다고 간주하는 것이다.
</p>

<p>
    어떤 값의 타입을 그 형태를 보고 짐작하는 타입 체크를 덕 타이핑(Duck Typing)이라 한다. 덕 타이핑 방식으로 데너블 체크를 한다면 아래의 코드와 같다.
</p>

```javascript
if (
    p !== null &&
    (
        typeof p === "object" ||
        typeof p === "function"
    ) &&
    typeof p.then === "funciont"
) {
    // 데너블로 간주한다.
} else {
    // 데너블이 아니다.
}
```

<p>
    `then()`이라는 이름의 함수 또는 객체를 엔진은 데너블이라고 자동 인식하여 특별한 규칙을 적용한다. `then()`이라는 함수가 있었다는 사실을 몰랐어도 사정은 달라지지 않는다.
</p>

```javascript
var o = {then: function() {}};

// v를 o의 [[prototype]]에 연결한다.
var v = Object.create(o);

v.someStuff = "cool";
v.otherStuff = "not so cool";
v.hasOwnProperty("then"); // false
```

<p>
    위의 코드에서 v는 언뜻 봐도 프로미스/데너블과 거리가 먼, 프로퍼티 몇 개 있는 평범한 객체다. 하지만 데너블 덕 타이핑 결과 v는 데너블로 판정받게 된다.
</p>

```javascript
Object.prototype.then = function() {};
Array.prototype.then = function() {};

var v1 = {hello: "world"};
var v2 = ["Hello", "World"];
```

<p>
    위의 코드에서 v1, v2 모두 데너블로 인식된다. 다른 개발자가 실수로/악의적으로 then을 `Object.prototype`, `Array.prototype` 또는 네이티브 프로토타입에 추가해도 이를 방지하거나 막을 길은 없다. 또한 `then()` 자리에 콜백 인자를 호출하지 않는 함수가 세팅되면 그런 값으로 귀결된 프로미스는 조용히 무한 루프의 늪에 빠진다.
</p>

### 3. 프로미스 믿음

- 콜백만 사용한 코드의 믿음성 문제
  - 너무 일찍 콜백을 호출
  - 너무 늦게 콜백을 호출
  - 너무 적게 또는 너무 많이 콜백을 호출
  - 필요한 환경/인자를 정상적으로 콜백에 전달 못함
  - 발생 가능한 에러/예외를 무시함

#### 너무 빨리 호출

<p>
    같은 작업인데도 어떨 때는 동기적으로, 어떨 때는 비동기적으로 끝나 결국 경합 조건에 이르게 되는 자르고 현상을 일으킬 코드인지 확인하는 문제다. 프로미스는 바로 이루어져도 프로미스의 정의상 동기적으로 볼 수는 없으니 이 문제는 영향받을 일이 없다. 따라서 `then()`을 호출하면 프로미스가 이미 귀결된 이후라 해도 `then()`에 건넨 콜백은 항상 비동기적으로만 부른다. 프로미스는 자르고를 알아서 예방한다.
</p>

#### 너무 늦게 호출

<p>
    프로미스는 `then()`에 등록한 콜백은 새 프로미스가 생성되면서 `resolve()`, `reject()` 중 어느 한쪽은 자동 호출하도록 스케줄링된다. 이렇게 스케줄링된 두 콜백은 다음 비동기 시점에 예상대로 실행될 것이다.
</p>

<p>
    동기적인 관찰은 불가능하므로 어떤 동기적인 작업 연쇄가 실제로 예정된 다른 콜백의 실행을 지연시키는 방향으로 움직일 수는 없다. 즉, 프로미스가 귀결되면 `then()`에 등록된 콜백들이 그다음 비동기 기회가 찾아왔을 때 순서대로 실행되며 어느 한 콜백 내부에서 다른 콜백의 호출에 영향을 주거나 지연시킬 일은 있을 수 없다.
</p>

```javascript
p.then(function() {
    p.then(function() {
        console.log("C");
    });
    console.log("A")
});
p.then(function() {
    console.log("B");
});
// A B C
```

<p>
    위의 코드에서 프로미스 작동 원리 덕분에 C가 끼어들어 B를 앞지를 가능성은 없다.
</p>

##### 프로미스 스케줄링의 기벽

<p>
    프로미스 스케줄링은 별개의 두 프로미스에서 연쇄된 콜백 사이의 상대적인 실행 순서를 장담할 수 없다. 두 프로미스 p1, p2가 모두 귀결된 상태라면 `p1.then();`, `p2.then();`에서 p1 콜백이 p2 콜백보다 당연히 먼저 실행되어야 할 것 같지만 애매한 경우가 있다.
</p>

```javascript
var p3 = new Promise(function(resolve, reject) {
    resolve("B");
});

var p1 = new Promise(function(resolve, reject) {
    resolve(p3);
});

p2 = new Promise(function(resolve, reject) {
    resolve("A");
});

p1.then(function(v) {
    console.log(v);
});

p2.then(function(v) {
    console.log(v);
});

// A B
```

<p>
    위의 코드에서 p1은 즉시값(Immediate Value)으로 귀결되지 않고 다른 프로미스 p3로 귀결되고 p3는 다시 B값으로 귀결된다. 이 때 p3는 p1으로, 비동기적으로 풀리므로(Unwrap) p1 콜백은 p2 콜백보다 비동기 잡 큐에서 후순위로 밀리게 된다.
</p>

<p>
    여러 프로미스에 걸친 콜백의 순서/스케줄링에 의존해선 안된다. 사실 처음부터 다중 콜백의 순서가 문제를 일으키지 않는 방향으로 코딩하는 편이 바람직하며, 가능하다면 피하는 게 좋다.
</p>

#### 한번도 콜백을 안 호출

<p>
    프로미스 스스로 귀결 사실을 알리지 못하게 막을 방도는 없다. 이룸/버림 콜백이 프로미스에 모두 등록된 상태라면 프로미스 귀결 시 둘 중 하나는 반드시 부른다. 만일 프로미스 스스로 어느 쪽으로도 귀결되지 않다면 경합이라는 상위 수준의 추상화를 이용하여 프로미스로 해결할 수 있다.
</p>

```javascript
// 프로미스를 타임아웃시키는 유틸리티
function timeoutPromise(delay) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            reject("타임아웃");
        }, delay)
    });
}

// foo()에 타임아웃을 건다.
Promise.race([
    foo(), // foo() 실행
    timeoutPromise(3000); // 3초 딜레이
])
.then(
    function() {
        // foo()가 제시간에 이루어짐
    },
    function(err) {
        // foo()가 버려졌거나 제시간에 이뤄지지 않음
        // err를 조사하여 원인을 파악
    }
);
```

#### 너무 가끔 너무 종종 호출

<p>
    콜백의 호출 횟수는 한 번이다. 따라서 너무 가끔은 곧 0번을 부른다는 뜻이다. 너무 종종 호출하는 경우 프로미스는 정의상 단 한번만 귀결된다.어떤 이유로 프로미스 생성 코드가 `resolve()`, `reject()` 중 하나 또는 모두를 여러 차례 호출하려고 하면 프로미스는 오직 최초의 귀결만 취하고 이후의 시도는 조용히 무시된다. 프로미스는 딱 한 번만 귀결되기 때문에 `then()`에 등록한 콜백 또한 한 번씩만 호출된다. 물론 같은 콜백을 두 번 이상 등록하면 그 횟수만큼 부를 것이다.
</p>

#### 인자/환경 전달 실패

<p>
    프로미스 귀결 값은 딱 하나 뿐이다. 명시적인 값으로 귀결되지 않으면 그 값은 undefined로 세팅된다. 하지만 값이야 어떻든 지금이든 나중이든 프로미스는 모든 등록한 콜백으로 반드시 전해진다.
</p>

<p>
    `resolve()`, `reject()` 함수를 부를 때 인자를 여러 개 넘겨도 두 번째 이후 인자는 그대로 무시한다. 앞에서 이야기한 보장 체계를 위반한 것처럼 보이지만 엄밀히 따지면 프로미스 체계를 잘못 사용한 대가일 뿐이다. 다른 API 오용 사례로부터 프로미스가 일관적으로 작동하도록 보호 장치가 마련되어 있다. 값을 여러 개 넘기고 싶다면 배열이나 객체로 꼭 감싸야 한다.
</p>

<p>
    자바스크립트 함수는 자신이 정의된 스코프의 클로저를 항상 간직하므로 클로저를 통해 얼마든지 계속 주변 상태에 접근할 수 있다.
</p>

#### 에러/예외 삼키기

<p>
    어떤 이유로 프로미스를 버리면 그 값은 버림 콜백으로 전달된다. 하지만 프로미스가 생성 중 또는 귀결을 기다리는 도중 언제라도 TypeError, ReferenceError 등의 자바스크립트 에러가 나면 예외를 잡아 주어진 프로미스를 강제로 버린다.
</p>

```javascript
var p = new Promise(function(resolve, reject) {
    foo.bar(); // foo는 정의된 바 없으니 에러가 난다.
    resolve(42); // 실행되지 않는다.
});

p.then(
    function fulfilled() {
        // 실행되지 않는다.
    },
    function rejected(err) {
        // foo.bar()에서 에러가 나므로
        // err는 TypeError 예외 객체일 것이다.
    }
);
```

<p>
    `foo.bar()`에서 발생한 자바스크립트 예외는 프로미스 버림 콜백에서 잡아 대응할 수 있다. 에러 아닌 요소는 비동기적이면서 에러가 나면 동기적으로 반응하여, 앞으로 일어날지 모를 문제를 효과적으로 차단할 수 있기 때문에 매우 중요한 세부분이다. 프로미스는 자바스크립트 예외조차도 비동기적 작동으로 바꾸어 경합 조건을 상당히 줄인다.
</p>

```javascript
var p = new Promise(function(resolve, reject) {
    resolve(42);
});

p.then(
    function fulfilled(msg) {
        foo.bar();
        console.log(msg); // 실행되지 않는다.
    },
    function rejected(err) {
        // 절대 실행되지 않는다.
    }
);
```

<p>
    위의 코드는 더 깊숙한 곳에서 발생한 에러를 감지하지 못한 것이다. `p.then()`가 반환한 또 다른 프로미스에서 TypeError 예외가 나면서 버려지게 된다. p는 이미 42란 값으로 이루어진 상태여서 나중에 p의 귀결 상태를 감지하는 코드에서 에러가 나도 그 상태를 버림으로 바꿀 수는 없다.
</p>

<p>
    원리에도 위배되지만 실제로 그렇게 작동하면 혼란을 야기할 수 있다. 가령, 프로미스 p에 `then()` 콜백이 여러 개 등록된 상태여서 어떤 콜백은 호출하고 어떤 콜백은 호출하지 않을 수 있다면 매우 불분명한 로직이 될 것이다.
</p>

#### 미더운 프로미스

<p>
    프로미스는 콜백을 완전히 없애기 위한 장치가 아니다. 단지 프로미스는 콜백을 넘겨주는 위치만 달리할 뿐이다.
</p>

<p>
    반환받은 뭔가가 실제로 미더운 프로미스라고 어떻게 장담할 수 있을까라는 의문에 해결책은 ES6 프로미스 구현체에 추가된 `Promise.resolve()` 함수다. 즉시값 또는 프로미스 아닌(Non-Promise)/데너블 아닌(Non-Thenable) 값을 `Promise.resolve()`에 건네면 이 값으로 이루어진 프로미스를 얻게 된다.
</p>

```javascript
var p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

var p2 = Promise.resolve(42);
```

<p>
    위의 코드에서 p1과 p2의 값은 같다. 아래의 코드처럼 `Promise.resolve()`에 프로미스가 넘어가도 결과는 같다.
</p>

```javascript
var p1 = Promise.resolve(42);
var p2 = Promise.resolve(p1);

p1 === p2; // true
```

<p>
    중요한 것은 프로미스가 아닌 데너블 값을 `Promise.resolve()`에 주면 일단 그 값을 풀어보고 최종적으로 프로미스 아닌 것 같은 구체적인 값이 나올 때까지 계속 풀어본다는 점이다.
</p>

### 4. 연쇄 흐름

<p>
    프로미스는 단일-단계(Single-Step) 작업만을 대상으로 만들어진 체계가 아니다. 프로미스는 블록처럼 여러 개를 길게 늘어놓으면 일련의 비동기 단계를 나타낼 수 있다. 프로미스에 내재된 두 가지 작동 방식은 다음과 같다.
</p>

- 프로미스에 `then()`을 부틀 때마다 생성하여 반환하는 새 프로미스를 계속 연쇄할 수 있다.
- `then()`의 이룸 콜백 함수가 반환한 값은 어떤 값이든 자동으로 연쇄된 프로미스의 이룸으로 세팅된다.

```javascript
var p = Promise.resolve(21);

var p2 = p.then(function(v) {
    console.log(v); // 21
    return v * 2;
});

// p2를 연쇄
p2.then(function(v) {
    console.log(v); // 42
});
```

<p>
    `v*2`를 반환하면서 첫 번째 `then()` 호출이 만들어준 신생 프로미스 p2를 이룬다. p2의 `then()`을 호출하면 `return v*2;`에서 이룸값을 받는다. 물론 `p2.then()`는 새로운 프로미스를 생성하므로 다른 변수에 보관해도 되지만 자꾸 선언하는 건 다소 번거로우며, 굳이 선언하지 않아도 쉽게 연쇄할 수 있다.
</p>

<p>
    프로미스 시퀀스가 각 단계마다 비동기적으로 작동하게 만드는 핵심은 `Promise.resolve()`에 넘긴 값이 어떤 최종값이 아닌 프로미스/데너블일 때 `Promise.resolve()`의 작동 로직이다. `Promise.resolve()`는 진짜 프로미스를 받으면 도로 뱉어내며, 데너블을 받으면 일단 한 번 풀어보고 아니면 원하는 값이 나올 때까지 재귀적으로 계속 풀어본다. 만약 감싼 프로미스에 비동기성을 부여해도 작동 방식은 동일하다.
</p>

```javascript
var p = Promise.resolve(21);

p.then(function(v) {
    console.log(v); // 21

    // 프로미스를 생성하여 반환
    return new Promise(function(resolve, reject) {
        // 비동기성 부여
        setTimeout(function() {
            resolve(v * 2);
        }, 1000);
    });
})
.then(function(v) {
    console.log(v); // 1초 후에 실행, 42
})
```

<p>
    위의 코드처럼 원하는 개수만큼 비동기 단계로 구성된 시퀀스를 만들어, 필요하다면 각 단계별로 그 다음 단계로 진행을 미룰 수 있다. 물론 예제처럼 단계별로 어떤 값을 반드시 전달해야 할 필요는 없다. 반환값이 명시적이지 않으면 암시적으로 undefined로 할당되며 서로 연쇄되는 방식은 변함없다. 따라서 프로미스의 귀결은 다음 단계로의 진행을 신호한다고 볼 수 있다.
</p>

```javascript
// ajax({url}, {callback})같은 유틸리티가 있다고 하자

// 프로미스-인식형 AJAX
 function request(url) {
     return new Promise(function(resolve, reject) {
         // ajax() 콜백이 이 프로미스의 resolve() 함수가 된다.
         ajax(url, resolve);
     });
 }

 request("http://some.url.1/")
 .then(function(response1) {
     return("http://some.url.2/?v=" + response1);
 })
 .then(function(response2) {
     console.log(response2);
 });
 ```

<p>
    `request()`로 첫 번째 URL을 요청하여 연쇄 1단계를 암시적으로 생성하고 첫 번째 `then()`에서 만들어진 프로미스를 연쇄한다. response1을 받으면 이 값으로 두 번째 URL을 조합하여 다시 `request()` 요청을 한다. 그 후에 두 번째 `request()` 프로미스가 넘어오고 3단계에서 AJAX호출이 끝나기만을 기다린다. 결국 response2가 당도하면 화면에 출력한다.
</p>

<p>
    프로미스 연쇄는 다단계 비동기 시퀀스에서 흐름제어 뿐만 아니라 단계와 단계 사이에 메시지를 전달하는 채널로도 쓰인다.
</p>

<p>
    만일 프로미스 연쇄의 어느 단계에서 문제가 발생한다면, 에러/예외는 프로미스 단위로 한정되므로 전체 연쇄 어느 곳에서 난 에러라도 모두 잡아 바로 그 지점부터 리셋을 하여 연쇄를 다시 정상 가동시킨다.
</p>

```javascript
// 1단계
request("http://some.url.1")

// 2단계
.then(function(response1) {
    foo.bar(); // 정의되어 있지 않아 에러 발생

    // 실행되지 않음
    return request("http://some.url.2/?v=" + response1);
})

// 3단계
.then(
    function fulfilled(response2) {
        // 실행되지 않음
    },
    // 에러를 잡기 위한 버림 처리기
    function rejected(err) {
        console.log(err);
        // foo.bar()에서 TypeError 발생
        return 42;
    }
)

// 4단계
.then(function(msg) {
    console.log(msg); // 42
});
```

<p>
    위의 코드는 2단계에서 에러가 나면 3단계 버림 처리기가 이를 잡아 필요 시 어떤 값을 반환해 다음 4단계의 프로미스가 이루어지게 한다. 결국 전체 연쇄는 다시 이룸 상태로 돌아간다.
</p>

```javascript
var p = new Promise(function(resolve, reject) {
    reject("????");
});

var p2 = p.then(
    function fulfilled() {
        // 실행되지 않음
    }
    // 버림 처리기가 생략되거나 함수 아닌 다른 값이 전달되면
    // 다음과 같은 버림 처리기가 있다고 가정하여 처리
    // function(err) {
    // throw err;
    // }
);
```

<p>
    프로미스의 `then()`을 부를 때 이룸 처리기만 넘기면 버림 처리기는 기본 처리기로 대체된다. 위의 코드처럼 기본 버림 처리기는 단순히 에러를 다시 던지는 역활을 하므로 p2를 던져진 에러와 같은 버림 사유로 강제 폐기한다. 명확하게 정의된 버림 처리기를 만날 때까지 프로미스 연쇄를 타고 계속 에러가 전파되도록 만들어놓은 장치다.
</p>

<p>
    `then()`에 온전한 이룸 처리기를 넘기지 않을 경우에도 기본 처리기로 자동 대체된다. 기본 이룸 처리기는 받은 값을 다음 단계에 그대로 전하기만 한다.
</p>

- 흐름 제어를 연쇄할 수 있는 프로미스 고유의 특징
  - `then()`을 호출하면 그 결과 자동으로 새 프로미스를 생성하여 반환한다.
  - 이룸/버림 처리기 안에서 어떤 값을 반환하거나 예외를 던지면 이에 따라 새 프로미스가 귀결된다.
  - 이룸/버림 처리기가 반환한 프로미스는 풀린 상태로 그 귀결 값이 무엇이든 간에 결국 현재의 `then()`에서 반환된, 연쇄된 프로미스의 귀결 값이 된다.

### 5. 에러 처리

<p>
    동기적인 `try ... catch` 구문은 가장 일반적인 에러 처리 형태다. 하지만 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물이다. 콜백에선 에러 처리 패턴에 관한 몇 가지 표준이 있는데, 아래의 예제는 에러-우선 콜백(Error-First Callback) 스타일로 작성한 코드다.
</p>

```javascript
function foo(cb) {
    setTimeout(function() {
        try {
            var x = baz.bar();
            cb(null, x);
        } catch (err) {
            cb(err);
        }
    }, 100);
}

foo(function(err, val) {
    if (err) {
        console.error(err);
    } else {
        console.log(val);
    }
});
```

<p>
    위 예제에서 `try ... catch`는 baz.bar() 호출 결과가 즉시 동기적으로 성공/실패한다는 전제하에서만 작동한다. `baz.bar()` 함수 자체가 비동기로 작동하면 그 내부에서 발생한 에러는 잡을 수 없다. `foo()` 함수에 전달한 콜백은 첫 번째 인자 err를 통해 에러 신호를 감지할 것이다. err가 있으면 에러가 난 거고 없으면 문제가 없었다는 뜻이다.
</p>

<p>
    위의 방식으로 비동기적 에러 처리를 구현할 수 있지만 여러 개를 조합하면, 수준이 제각각인 에러 우선 콜백이 뒤엉키며 결국 콜백 지옥을 피하기 어렵다. 프로미스는 분산-콜백(Split-Callback) 스타일로 이룸/버림 각각의 콜백을 지정하여 에러 처리를 한다.
</p>

```javascript
var p = Promise.reject("???");

p.then(
    function fulfiled(msg) {
        // 실행되지 않는다.
        console.log(msg);
    },
    function rejected(err) {
        console.log(err); // ???
    }
);
```

<p>
    위의 코드와 같은 에러 처리 패턴은 표면적으로는 명쾌한 것 같지만, 프로미스 에러 처리는 미묘한 부분이 숨겨져 있다.
</p>

```javascript
var p = Promise.resolve(42);

p.then(
    function fulfiled(msg) {
        // 숫자에는 문자열 함수가 없으니
        // 에러를 던질 것이다.
        console.log(msg.toLowerCase());
    },
    function rejected(err) {
        // 실행되지 않는다.
    }
);
```

<p>
    위의 코드에서 에러 처리기의 소속은 프로미스 p이고 p는 42 값으로 이루어진 상태이다. p는 불변값이므로 에러 알림은 오직 `p.then()`이 반환한 프로미스만이 가능한데 여기서는 이 프로미스를 포착할 방법이 없다.
</p>

#### 절망의 구덩이

<p>
    사라진/버려진 프로미스의 에러가 함께 파묻히는 걸 막으려면 반드시 프로미스 연쇄 끝부분에 `catch()`를 써야 한다고 주장하는 개발자들이 있다.
</p>

```javascript
var p = Promise.resolve(42);
p.then(
    function fulfilled(msg) {
        console.log(msg.toLowerCase());
    }
)
.catch(handleErrors);
```

<p>
    버림 처리기를 따로 `then()`에 넘기지 않았기에 기본 버림 처리기로 대체되면서 에러는 다음 연쇄 프로미스로 그냥 전파된다. 따라서 결국 p로 유입된 에러 및 p 이후 귀결 중 발생한 에러 모두 `handleError()`로 들어온다. 하지만 `handleError()` 역시 실패할 가능성이 있기 때문에 무조건 연쇄 끝에 `catch()`를 붙일 순 없다. 프로미스 연쇄의 마지막 단계에 방치된 프로미스에서 에러가 나면 잡히지 않고 매달려 있을 가능성은 항상 존재한다.
</p>

#### 잡히지 않은 에러 처리

<p>
    일부 프로미스 라이브러리는 전역 미처리 버림(Global Unhandled Rejection) 처리기 같은 것을 등록하는 메서드를 추가하여 전역 범위로 에러를 던지는 대신 이 메서드가 대신 호출되도록 해놓았다. 하지만 잡히지 않은 에러인지 식별하기 위해 버림 직후 임의의 시간 동안 타이머를 걸어놓는 식으로 구현한 것이다. 프로미스가 버려졌으나 타이머 작동 전 등록된 에러 처리기가 없으면 앞으로도 처리기를 등록하지 않겠다는 의사로 간주되어 에러는 잡히지 않는다.
</p>

<p>
    프로미스 연쇄 끝에 `done()`을 붙여 완료 사실을 천명해야 한다고 조언하는 사람들도 있다. 하지만 `done()`은 프로미스를 생성, 반환하는 함수가 아니므로 `done()`에 넘긴 콜백이 존재하지도 않는 연쇄된 프로미스에 문제를 알려줄 리 만무하다. 따라서 `done()` 버림 처리기 내부에서 에러가 나면 잡히지 않은 전역 에러로 던진다.
</p>

```javascript
var p = Promise.resolve(42);
p.then(
    function fulfilled(msg) {
        console.log(msg.toLowerCase());
    }
)
.done(null, handleErrors);
// handleErrors()에서 예외가 발생하면
// 여기서 전역적으로 던진다.
```

<p>
    하지만 위의 코드의 큰 문제점은 ES6 표준에 들어있지 않기 때문에 그럴듯해 보여도 믿을 만한 보편적인 해결 방안과는 거리가 있다.
</p>

<p>
    브라우저는 언제 객체가 가비지 콜렉션될지 정확히 알고 추적할 수 있다. 따라서 브라우저는 프로미스 객체를 추적하면서 언제 가비지를 수거하면 될지 알고 있으며, 프로미스가 버려지면 그 사유가 논리적인, 잡히지 않은 에러이므로 개발자 콘솔창에 표시해야 할지 여부를 확실하게 결정할 수 있다.
</p>

<p>
    하지만 브라우저가 제대로 가비지 콜렉션되지 않으면 브라우저의 가비지 콜렉션 감지 기능은 침묵 속의 프로미스를 파악/진단하는 데 도움이 되지 않는다.
</p>

#### 성공의 구덩이

- 기본적으로 프로미스는 그 다음 잡/이벤트 루프 틱 시점에 에러 처리기가 등록되어 있지 않을 경우 모든 버림을(개발자 콘솔창에) 알리도록 되어 있다.
- 감지되기 전까지 버림 프로미스의 버림 상태를 계속해서 유지하려면 `defer()`를 호출해서 해당 프로미스에 관한 자동 에러 알림 기능을 끈다.

```javascript
var p = Promise.reject("???").defer();

// foo()는 프로미스-인식형 함수
foo(42);
.then(
    function fulfilled() {
        return p;
    },
    function rejected(err) {
        // foo() 에러 처리
    }
);
...
```

<p>
    p를 생성할 때 버림 상태를 사용/감지하려면 잠시 대기해야 하므로 `defer()`를 호출하는 데, 이렇게 하면 전역 범위로 알림이 발생하지 않는다. `defer()`는 계속 연쇄할 목적으로 같은 프로미스를 단순 반환한다. `foo()`가 반환한 프로미스에는 곧바로 에러 처리기가 달리므로 알림 기능은 암시적으로 배제되고 전역 알림 또한 일어나지 않는다.
</p>

<p>
    반면 `then()`이 반환한 프로미스엔 `defer()`나 에러 처리기 같은 것이 달려있지 않아 프로미스가 버림되면 잡히지 않은 에러 형태로 개발자 콘솔창에 나타나게 될 것이다. 이러한 설계를 성공의 구덩이라고 한다. 모든 에러는 기본적으로 처리 또는 통지된다. 이 접근 방식이 유일하게 위험한 경우는, 프로미스를 `defer()` 했으나 실제로 버림을 감지/처리하지 못했을 때다.
</p>

### 6. 프로미스 패턴

#### Promise.all([])

<p>
    복수의 병렬/동시 작업이 끝날 때까지 진행하지 않고 대기하는 관문이라는 장치가 있다. 어느 쪽이 먼저 끝나든지 모든 작업이 다 끝나야 게이트가 열리고 다음으로 넘어간다. 프로미스에서는 `Promise.all([])`을 사용한다.
</p>

```javascript
// request()는 프로미스-인식형 AJAX 유틸리티

var p1 = request("http://some.url.1/");
var p2 = request("http://some.url.2/");

Promise.all([p1, p2])
.then(function(msgs) {
    // p1, p2 둘 다 이루어져
    // 여기에 메시지가 전달된다.
    return request(
        "http://some.url.3/?v=" + msgs.join(",")
    );
})
.then(function(msg) {
    console.log(msg);
});
```

<p>
    `Promise.all([])`는 보통 프로미스 인스턴스들이 담긴 배열 하나를 인자로 받고 호출 결과 반환된 프로미스는 이룸 메시지를 수신한다. 이 메시지는 배열에 나열한 순서대로 프로미스들을 통과하면서 얻어진 이룸 메시지의 배열이다.
</p>

<p>
    `Promise.all([])`이 반환한 메인 프로미스는 자신의 하위 프로미스들이 모두 이루어져야 이루어질 수 있다. 단 한 개의 프로미스라도 버려지면 `Promise.all([])` 프로미스 역시 곧바로 버려지며 다른 프로미스 결과도 무효가 된다.
</p>

#### `Promise.race([])`

<p>
    최초의 프로미스만 인정하고 나머지는 무시해야 할 때도 있다. 예전부터 걸쇠(Latch)라는 패턴으로, 프로미스에서는 경합(Race)라고 한다. `Promise.race([])` 역시 하나 이상의 프로미스, 데너블, 즉시값이 포함된 배열 인자 1개를 받으며, 하나라도 이루어진 프로미스가 있을 경우 이루어지고 하나라도 버려지는 프로미스가 있으면 버려진다.
</p>

#### all([])/race([])의 변형

<p>
    ES6 프로미스 내장된 `Promise.all([])`, `Promise.race([])`을 변형한 패턴 중에 쓰이는 것
</p>

- `none([])`
  - `all([])`과 비슷하지만 이룸/버림이 정반대다. 따라서 모든 프로미스는 버려져야 하며, 버림이 이룸값이 되고 이룸이 버림값이 된다.
- `any([])`
  - `all([])`과 유사하나 버림은 모두 무시하며, 하나만 이루어지면 된다.
- `first([])`
  - `any([])`의 경합과 비슷하다. 일단 최초로 프로미스가 이루어지고 난 이후엔 다른 이룸/버림은 간단히 무시한다.
- `last([])`
  - `first([])`와 거의 같고 최후의 이룸 프로미스 하나만 승자가 된다는 것만 다르다.

#### 동시 순회

<p>
    프로미스 리스트를 순회하면서 각각에 대해 어떤 처리를 하고 싶은 경우가 있다. 프로미스별로 처리할 작업이 근본적으로 동기적이라면 이전 예제에서 `forEach()`를 썼던 것처럼 이들 함수만 있어도 충분하다.
</p>

### 7. 프로미스 API 복습

#### new Promise() 생성자

<p>
    `Promise()` 생성자는 항상 new와 함께 사용하며 동기적으로/즉시 호출할 콜백 함수를 전달해야 한다. 이 함수에는 다시 프로미스를 귀결 처리할 콜백 2개를 넘기는데 `resolve()`와 `reject()`라고 명명하는 것이 보통이다.
</p>

```javascript
var p = new Promise(function(resolve, reject) {
    // resolve()는 프로미스를 귀결/이룬다.
    // reject()는 프로미스를 버린다.
});
```

<p>
    `reject()`는 그냥 프로미스를 버리지만 `resolve()`는 넘어온 값을 보고 이룸/버림 중 한 가지로 처리한다. 즉시값, 프로미스 아닌/데너블 아닌 값이 `resolve()`에 흘러오면 이 프로미스는 해당 값으로 이루어진다. 반면, `resolve()`에 진짜 프로미스/데너블 값이 전달되면 재귀적으로 풀어보고 결국 그 최종값이 프로미스의 마지막 귀결/상태가 된다.
</p>

#### Promise.resolve()와 Promise.reject()

<p>
    `Promise.reject()`는 이미 버려진 프로미스를 생성하는 지름길이다. 따라서 두 프로미스는 본질적으로 동등하다.
</p>

```javascript
var p1 = new Promise(function(resolve, reject) {
    reject("???");
});

var p2 = Promise.reject("???");
```

<p>
    `Promise.reject()`와 마찬가지로 `Promise.resolve()`는 이미 이루어진 프로미스를 생성하는 용도로 쓴다. `Promise.resolve()`는 데너블 값을 재귀적으로 풀어보고 그 최종 귀결 값이 결국 반환된 프로미스에 해당된다.
</p>

```javascript
var fulfilledTh = {
    then: function(cb) {cb(42);}
};

var rejectedTh = {
    then: function(cb, errCb) {
        errCb("Oops");
    }
};

var p1 = Promise.resolve(fulfilledTh);
var p2 = Promise.resolve(rejectedTh);

// p1은 이룸 프로미스
// p2은 버림 프로미스
```

<p>
    `Promise.resolve()`에 진짜 프로미스를 넣으면 아무 일도 하지 않는다. 따라서 종류를 모르는 값을 `Promise.resolve()`에 넣어봤는데 우연히 진짜 프로미스더라도 오버헤드는 없다.
</p>

#### then()과 catch()

<p>
    각 프로미스 인스턴스엔 `then()`, `catch()` 메서드가 들어있고 프로미스에 이룸/버림 처리기를 등록할 수 있다. 프로미스가 귀결되면 두 처리기 중 하나만 언제나 비동기적으로 호출된다.
</p>

<p>
    `then()`은 하나 또는 2개의 인자를 받는데 첫 번째는 이룸 콜백, 두 번째는 버림 콜백이다. 어느 한쪽을 누락하거나 함수가 아닌 값으로 지정하면 각각 기본 콜백으로 대체된다. 기본 이룸 콜백은 그냥 메시지를 전달하기만 하고 기본 버림 콜백은 단순히 전달받은 에러 사유를 도로 던진다.
</p>

<p>
    `catch()`는 버림 콜백 하나만 받고 이룸 콜백은 기본 이룸 콜백으로 대체한다. 쉽게 말하면 `then(null, )`이나 다름없다.
</p>

```javascript
p.then(fulfilled);
p.then(fulfiled, rejected);
p.catch(rejected); // 또는 p.then(null, rejected)
```

<p>
    `then()`, `catch()`도 새 프로미스를 만들어 반환하므로 프로미스 연쇄 형태로 흐름 제어를 표현할 수 있다. 이룸/버림 콜백에서 예외가 발생하면 반환된 프로미스는 버린다. 콜백 반환 값이 즉시값, 프로미스 아닌/데너블 아닌 값이면 반환된 프로미스의 이룸값으로 지정한다. 이룸 처리기가 특정 프로미스나 데너블 값을 반환하면 이 값을 풀어 반환된 프로미스의 귀결 값이 된다.
</p>

#### Promise.all([])과 Promise.race([])

<p>
    `Promise.all([])`, `Promise.race([])`는 프로미스를 생성하여 반환하는 ES6 프로미스 API의 정적 헬퍼 유틸리티다. 프로미스 귀결은 전적으로 전달받은 프로미스 배열에 따라 좌우된다.
</p>

<p>
    `Promise.all([])`은 주어진 모든 프로미스들이 이루어져야 메인 프로미스도 이루어지고 하나라도 버려지게 되면 메인 반환 프로미스 역시 곧바로 폐기된다. 이루어지면 각 프로미스의 이룸값이 담긴 배열을, 버려지면 처음 버려진 프로미스의 버림 사유를 돌려받는다.
</p>

<p>
    `Promise.race([])`는 최초로 귀결된 프로미스만 승자가 되고 그 귀결 값을 반환할 프로미스의 귀결 값으로 삼는다.
</p>

<p>
    ES6 프로미스는 API는 아주 간단하고 직관적이다. 기본적인 비동기 케이스라면 대부분 바로 이용할 수 있고 콜백 지옥에 빠진 코드를 재편성하여 개선하기 위한 출발점으로서 유용하다.
</p>

### 8. 프로미스 한계

#### 시퀀스 에러 처리

<p>
    프로미스의 설계 상 한계 탓에 프로미스 연쇄에서 에러가 나면 조용히 묻혀버리기 쉽다. 프로미스 연쇄는 구성원들을 한뎨 모아놓은 사슬에 불과하기 때문에 전체 연쇄를 하나의 뭔가로 가리킬 개체가 마땅치 않다. 즉, 일어날지 모를 에러를 밖에서는 감지할 도리가 없다.
</p>

<p>
    에러 처리기가 없는 프로미스 연쇄에서 에러가 나면 나중에 어딘가에서 감지될 때까지 연쇄를 하위로 전파한다. 그래서 이런 경우라면 연쇄의 마지막 프로미스를 가리키는 레퍼런스만 갖고 있으면 여기에 버림 처리기를 등록하여 전파되어 내려온 에러를 처리할 수 있다.
</p>

```javascript
// foo(), STEP2(), STEP3()은
// 모두 프로미스-인식형 유틸리티

var p = foo(42)
.then(STEP2)
.then(STEP3);
```

<p>
    p가 가리키는 대상은 이 연쇄의 첫 번째 프로미스가 아니라 `then(STEP3)` 호출 후 반환된 마지막 프로미스다. 또 프로미스 연쇄는 각 단계에서 자신의 에러를 감지하여 처리할 방법 자체가 없으니 p에 에러 처리기를 달아놓으면 연쇄 어디에서 에러가 나도 이를 받아 처리할 수 있다.
</p>

```javascript
p.catch(handleErrors);
```

<p>
    하지만 연쇄의 어느 단계에서 나름대로 에러 처리를 하면 `handleErrors()`는 에러를 감지할 방법이 없다.
</p>

#### 단일값

<p>
    프로미스는 정의 상 하나의 이룸값, 아니면 하나의 버림 사유를 가진다.
</p>

##### 값을 분할

```javascript
function getY(x) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve((3 * x) - 1);
        }, 100);
    });
}

function foo(bar, baz) {
    var x = bar * baz;
    return getY(x)
    .then(function(y) {
        return [x, y];
    });
}

foo(10, 20)
.then(function(msgs) {
    var x = msgs[0];
    var y = msgs[1];

    console.log(x, y); // 200 599
});
```

```javascript
function getY(x) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve((3 * x) - 1);
        }, 100);
    });
}

function foo(bar, baz) {
    var x = bar * baz;
    return [
        Promise.resolve(x),
        getY(x)
    ];
}

Promise.all(
    foo(10, 20)
)
.then(function(msgs) {
    var x = msgs[0];
    var y = msgs[1];
    console.log(x, y); // 200 599
});
```

<p>
    위의 코드들에서 후자가 프로미스 설계 사상을 더 잘 반영했다. 이렇게 해야 차후 x, y의 계산을 별도의 함수로 분리해서 리팩토링하기가 더 쉽고 호출부로 하여금 두 프로미스를 알아서 조정하도록 놔두는 편이 `foo()` 안에 세부 로직을 추상화하는 것보다 더 깔끔하고 유연하다.
</p>

##### 인자를 풀기/퍼뜨리기

<p>
    `var x = ...`와 `var y = ...` 할당은 불필요한 오버헤드다.
</p>

```javascript
function spread(fn) {
    return Function.apply.bind(fn, null);
}

Promise.all(
    foo(10, 20)
)
.then(
    spread(function(x, y) {
        console.log(x, y); // 200 599
    })
)
```

<p>
    위의 코드는 헬퍼 유틸리티에 기능적인 꼼수를 부린 것으로 앞선 코드보다 확실히 나아졌다.
</p>

#### 단일 귀결

<p>
    프로미스가 단 1회만 귀결된다는 점은 프로미스의 가장 중요한 본질이다.
</p>

```javascript
// click()은 click 이벤트를 DOM 요소에 바인딩한다.
// request()는 앞에서 정의한 프로미스-인식형 AJAX 요청이다.

var p = new Promise(function(resolve, reject) {
    click("#mybtn", resolve);
});

p.then(function(evt) {
    var btnID = evt.currentTarget.id;
    return request("http://some.url.1/?id=" + btnID);
})
.then(function(text) {
    console.log(text);
});
```

<p>
    위에서 정의한 로직은 버튼을 딱 한번만 눌러야 한다는 전제하에 실행된다. 버튼을 한번 더 누르면 프로미스 p는 이미 귀결된 상태이므로 두 번째 `resolve()`는 조용히 묻힌다. 따라서 각 이벤트가 발사되면 새 프로미스 연쇄 전체를 생성하는 식으로 기존 체계를 뒤엎을 필요가 있다.
</p>

```javascript
click("#myBtn", function(evt) {
    var btnID = evt.currentTarget.id;
    request("http://some.url.1/?id=" + btnID)
    .then(function(text) {
        console.log(text);
    });
});
```

<p>
    위의 코드는 click 이벤트가 발생할 때마다 전혀 새로운 프로미스 시퀀스가 등장할 것이다. 하지만 이벤트 처리기 안쪽에 전체 프로미스 연쇄를 정의하는 코드가 삽입되어 지저분해지며, 설계 관점에서 관심사/능력의 분리(SOC, Separation of Concerns/Capabilities)라는 기본 원리에 위배된다.
</p>

#### 타성

<p>
    프로미스를 활용하려고 할 때, 가장 실질적인 걸림돌은 프로미스-인식형이 아닌 기존 코드일 것이다. 콜백이 이미 뿌리깊이 자리잡은 코드라면 계속 같은 스타일을 유지하는 편이 쉽기 때문이다. 프로미스 체계는 전체적인 코드 접근 방식 자체가 다를 수 밖에 없고 근원부터 다른 경우도 더러 있다. 지금까지 개발자들이 버텨 온 옛날 코딩 방식을 조금 흔드는 정도가 아닌 까닭에 변화를 원한다면 굳은 결심이 필요하다.
</p>

#### 프로미스는 취소 불가

<p>
    일단 프로미스를 생성하여 이룸/버림 처리기를 등록하면, 도중에 작업 자체를 의미없게 만드는 일이 발생하더라도 외부에서 프로미스 진행을 멈출 방법이 없다. 수많은 프로미스 추상화 라이브러리에서 프로미스 취소 기능을 제공하고 있지만 특정한 프로미스의 사용자(Consumer)/감시자(Observer)가 같은 프로미스를 바라보는 다른 사용자에게까지 영향을 끼칠 수 있다는 문제가 있다. 이는 미랫값의 믿음성 원리에 위배될 뿐만 아니라 원격 작용(Action At A Distance)이라는 안티 패턴을 구현한 것이기도 하다.
</p>

#### 프로미스 성능 및 정리

<p>
    프로미스가 비록 약간 느린 건 사실이지만 그 대신 믿음성, 예측성, 조합성과 같은 장점을 고루 누릴 수 있다.
</p>

<p>
    프로미스는 콜백식 코드에서 문제였던 제어의 역전 문제를 해결했다. 프로미스가 콜백을 완전히 없애는 건 아니며 다만, 기존 콜백 코드를 믿을 만한 중계자 역활을 수행하는 유틸리티를 통해 잘 조정하여 서로 조화롭게 작동할 수 있도록 유도한 것이다. 프로미스 연쇄는 비동기 흐름을 순차적으로 표현하는 더 나은 방법이다.
</p>
