# Part 2 비동기와 성능

## Chapter 1 비동기성: 지금과 나중

### 1. 프로그램 덩이

<p>
    자바스크립트 프로그램은 .js 파일 하나로도 작성할 수 있지만 보통은 여러 개의 덩이(Chunk), 곧 지금 실행 중인 프로그램 덩이 하나 + 나중에 실행할 프로그램 덩이들로 구성된다. 가장 일반적인 프로그램 덩이 단위는 함수다. 지금 당장 끝낼 수 없는 작업은 비동기적으로 처리되므로 프로그램을 중단(Blocking)하지 않는다.
</p>

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
var data = ajax("http://some.url.1");

console.log(data);
```

<p>
    표준 AJAX 요청은 동기적으로 작동하지 않아 data 변수에 결괏값을 할당할 수 없다. AJAX는 비동기적으로 '지금' 요청하고 '나중'에 결과를 받는다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법은 콜백 함수(Callback Function)를 사용하는 것이다.
</p>

```javascript
// ajax()는 라이브러리에 있는 임의의 AJAX 함수다.
ajax("http://some.url.1", function myCallbackFunction(data) {
    console.log(data);
});
```

<p>
    동기적인 AJAX 요청도 할 수 있지 않냐라고 할 수도 있다. 기술적으로는 가능하지만 브라우저 UI를 얼어붙게 할 뿐 아니라 사용자와 상호 작용이 마비될 수 있으니 사용하지 않는게 좋다.
</p>

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log("answer:", answer);
}

var answer = now();
setTimeout(later, 1000); // answer: 42
```

<p>
    위의 코드를 지금 덩이와 나중 덩이로 나누면 다음과 같다.
</p>

```javascript
// 지금 덩이
function now() {
    return 21;
}

function later() { .. }

var answer = now();

setTimeout(later, 1000);

// 나중 덩이
answer = answer * 2;
console.log("answer:", answer);
```

<p>
    프로그램을 시작하면 '지금' 덩이는 바로 실행되지만 `setTimeout()`은 '나중' 이벤트를 설정하는 함수이므로 `later()` 함수는 나중에 실행된다.
</p>

#### 비동기 콘솔

<p>
    `Console.*` 메서드는 그 작동 방법이나 요건이 명세에 따로 정해져 있지 않지만 호스팅 환경(Hosting Environment)에 추가된 기능이다. 따라서 브라우저와 자바스크립트 실행 환경에 따라 작동 방식이 다르고 혼동을 유발하기도 한다. 특히 `console.log()` 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다.
</p>

```javascript
var a = {
    index: 1
};

// 나중에
console.log(a); // ??

// 더 나중에
a.index++;
```

<p>
    개발자 도구 콘솔창에 `{index: 1}`이 표시되겠지만 간혹 브라우저가 콘솔 I/O를 백그라운드로 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 `a.index++`가 먼저 실행된 후 콘솔창에 객체 값이 전달되어 `{index: 2}`로 나올 때가 있다. `console.log()` 문 이후 변경된 객체의 프로퍼티 값이 콘솔에 표시되는 문제로 디버깅을 할 땐 이러한 I/O 비동기성이 원인이 될 수 있다는 점을 항상 염두에 두어야 한다.
</p>

### 2. 이벤트 루프

<p>
    자바스크립트 엔진은 반드시 호스팅에서 실행된다. 환경은 달라도 스레드(Thread)는 공통이다. 여러 프로그램 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프(Event Loop)라는 장치다. 자바스크립트 엔진은 애당초 시간이란 관념 따윈 없었고 임의의 코드 조각을 주는 대로 받아 처리하는 실행기일 뿐, 이벤트를 스케줄링하는 일은 언제나 엔진을 감싸고 있던 주위 환경의 몫이었다. 이벤트 루프는 아마 다음과 같이 구현되어 있을 것이다.
</p>

```javascript
// eventLoop는 큐(선입, 선출) 역활을 하는 배열이다
var eventLoop = [];
var event;

// 무한 실행
while (true) {
    // 틱 발생
    if (eventLoop.length > 0) {
        // 큐에 있는 다음 이벤트 조회
        event = eventLoop.shift();

        // 다음 이벤트를 실행
        try {
            event();
        } catch (err) {
            reportError(err);
        }
    }
}
```

<p>
    코드에 while 무한 루프가 있는데 이 루프의 매 순회(Iteration)를 틱(Tick)이라고 한다. 틱이 발생할 때마다 큐에 적재된 이벤트를 꺼내어 실행한다. `setTimeout()`은 콜백을 이벤트 루프 큐에 넣지 않는다. `setTimeout()`은 타이머를 설정하는 함수다. 타이머가 끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 틱에서 콜백을 꺼내어 실행한다.
</p>

<p>
    만약 이벤트 루프가 원소로 가득 차있다면 일단 콜백은 맨 끝에서 대기한다. `setTimeout()` 타이머가 정확한 타이밍에 작동하지 않는 이유가 바로 이 때문이다. 적어도 지정한 시간 이전에 콜백이 실행되지 않을 거란 사실은 보장할 수 있지만 정확히 언제 실행될지는 이벤트 루프 큐의 상황에 따라 달라진다.
</p>

### 3. 병렬 스레딩

<p>
    프로세스와 스레드는 가장 많이 쓰는 병렬 컴퓨팅(Parallel Computing) 도구로, 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다. 반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없다. 병렬성(Parallelism)과 직렬성(Serialism)이 나뉜 스레드에서 이벤트 루프를 협동(Cooperation)하는 형태로 공존하는 모십이다. 병렬 실행 스레드 인터리빙(Interleaving)과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위(Granularity)에서 일어난다.
</p>

```javascript
function later() {
    answer = answer * 2;
    console.log("answer:", answer);
}
```

<p>
    `later()` 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행 중인 스레드 입장에선 실제로 여러 상이한 저수준의 작업들이 일어날 수 있다. 예컨대, `answer = answer * 2`는 '현재 answer 값 조회 -> 곱셈 연산 수행 -> 결괏값을 다시 answer 변수에 저장' 순으로 처리한다. 단일-스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 별문제 없다. 하지만 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템에선 예상치 못한 일들이 일어날 수 있다.
</p>

```javascript
var a = 20;

function foo() {
    a = a + 1;
}

function bar() {
    a = a * 2;
}

ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

<p>
    자바스크립트는 단일-스레드로 작동하니까 foo() -> bar() 순서로 실행하면 결괏값은 42지만 반대로 bar() -> foo() 순서면 41이 된다. 같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다. foo와 bar를 실행하는 두 스레드의 의사 코드 목록은 다음과 같다.
</p>

```javascript
// 스레드 1, X와 Y는 임시 메모리 공간이다
foo():
    a. 'a' 값을 'X'에 읽어들인다.
    b. '1'을 'Y'에 저장한다.
    c. 'X'와 'Y'를 더하고 그 결괏값을 'X'에 저장한다.
    d. 'X' 값을 'a'에 저장한다.

// 스레드 2, X와 Y는 임시 메모리 공간이다
bar():
    a. 'a' 값을 'X'에 읽어들인다.
    b. '1'을 'Y'에 저장한다.
    c. 'X'와 'Y'를 더하고 그 결괏값을 'X'에 저장한다.
    d. 'X' 값을 'a'에 저장한다.
```

<p>
    위의 예시는 중간 단계에서 X와 Y라는 메모리 공간을 공유하는 것이 문제이다. 자바스크립트는 절대로 스레드 간에 데이터를 공유하는 법이 없으므로 비결정성의 수준(Level of Nondeterminism)은 문제가 되지 않는다. 하지만 자바스크립트 프로그램이 항상 결정적이란 소리도 아니다.
</p>

#### 완전-실행

<p>
    자바스크립트의 작동 모드는 단일-스레드이므로 `foo()` 내부의 코드는 원자적이다. 일단 `foo()`가 실행되면 이 함수 전체 코드가 실행되고 나서야 `bar()` 함수로 옮아간다는 뜻이다. 이를 완전-실행(Run-to-Completion)이라 한다.
</p>

```javascript
var a = 1;
var b = 2;

function foo() {
    a++;
    b = b * a;
    a = a + 3;
}

function bar() {
    b--;
    a = 8 + b;
    b = a * 2;
}

ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

<p>
    `foo()`와 `bar()`는 상대의 실행을 방해할 수 없으므로 이 프로그램의 결괏값은 먼저 실행되는 함수가 좌우된다. 만약 문(Statement) 단위로도 스레딩이 일어나면 문별 인터리빙이 발생하여 경우의 수는 기하급수적으로 늘어난다. 위의 코드를 나누면 다음과 같다.
</p>

```javascript
// 덩이 1
var a = 1;
var b = 2;

// 덩이 2
a++;
b = b * a;
a = b + 3;

// 덩이 3
b--;
a = 8 + b;
b = a * 2;
```

<p>
    덩이 1은 동기 코드이고 덩이 2와 3은 비동기 코드로 일정 차이를 두고 실행된다. 덩이 2와 3은 선발순(Either-Fisrt Order)으로 실행되므로 결과는 다음 둘 중 하나다.
</p>

```javascript
// 결과 1
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;

a; // 11
b; // 22

// 결과 2
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;


// foo()
a++;
b = b * a;
a = b + 3;

a; // 183
b; // 180
```

<p>
    똑같은 코드인데 결괏값은 두 가지이므로 이 프로그램은 비결정적이다. 그러나 여기서 비결정성은 함수의 순서에 따른 것이지, 스레드처럼 문의 순서 수준까지는 아니다. 즉, 스레드보단 결정적이라고 할 수 있다. 자바스크립트에서는 함수 순서에 따른 비결정성을 흔히 경합 조건(Race Condition)이라고 표현한다.
</p>

### 4. 동시성

<p>
    사용자가 스크롤바를 아래로 내리면 계속 갱신된 상태 리스트가 화면에 표시되는 웹 페이지를 만들고자 할 때, 이런 기능은 적어도 2개의 분리된 프로세스를 동시에 실행할 수 있어야 제대로 기능을 구현할 수 있다.
</p>

<p>
    첫 번째 프로세스는 사용자가 페이지를 스크롤바로 내리는 순간 발생하는 onscroll 이벤트에 반응한다. 두 번째 프로세스는 AJAX 응답을 받는다. 만약 급한 사용자가 아주 빨리 스크롤바를 내리면 처음 수신된 응답을 처리하는 도중 2개 이상의 onscroll 이벤트가 발생하기에 십상이고 onscroll 이벤트와 AJAX 요청 이벤트가 아주 빠르게 발생하며 인터리빙 된다.
</p>

<p>
    동시성은 복수의 프로세스가 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다. 동시성은 처리 수준(operation-level) 병행성과 상반되는 개념의 프로세스 수준의 병행성이라 할 수 있다.
</p>

<p>
    주어진 시구간 동안 독립적인 각 프로세스를 이벤트/처리 목록으로 시각화하면 다음과 같다.
</p>

```javascript
// 프로세스 1, onscroll 이벤트
onscroll, request 1
onscroll, request 2
onscroll, request 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
onscroll, request 7

// 프로세스 2, AJAX 응답 이벤트
response 1
response 2
response 3
response 4
response 5
response 6
response 7
```

<p>
    onscroll 이벤트와 AJAX 응답 이벤트는 동시에 발생할 수 있다. 하지만 자바스크립트는 한 번에 하나의 이벤트만 처리하므로 onscroll, request 2든 response 1이든 둘 중 어느 한쪽이 먼저 실해오디고 정확히 같은 시각에 실행되는 일은 켤코 있을 수 없다. 이벤트 루프 큐에서 이벤트들은 다음과 같이 인터리빙 된다.
</p>

```javascript
onscroll, request 1 <--- 프로세스 1 시작
onscroll, request 2
response 1          <--- 프로세스 2 시작
onscroll, request 3
response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
response 4
onscroll, request 7 <--- 프로세스 1 종료
response 6
response 5
response 7          <--- 프로세스 2 시작
```

<p>
    프로세스 1과 프로세스 2는 동시에 실행되지만 이들을 구성하는 이벤트들은 이벤트 류프 큐에서 차례대로 실행된다. response 6과 response 5의 순서는 단일-스레드 이벤트 루프의 동시성을 나타내는 하나의 표현 방식이다.
</p>

#### 비상호 작용

<p>
    어떤 프로그램 내에서 복수의 프로세스가 단계/이벤트를 동시에 인터리빙 할 때 이들 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호 작굥은 사실 의미가 없다. 프로세스 간 상호 작용이 일어나지 않는다면 비결정성은 완벽하게 수용 가능하다.
</p>

```javascript
var res = {};

function foo(results) {
    res.foo = results;
}

function bar(results) {
    res.bar = results;
}

ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

<p>
    위의 코드를 보면 2개의 동시 프로세스 `foo()`와 `bar()` 중 누가 먼저 실행될지 알 수는 없지만 적어도 서로에게 아무런 영향을 끼치지 않고 개별 작동하여 실행 순서를 문제 삼을 필요가 없다.
</p>
