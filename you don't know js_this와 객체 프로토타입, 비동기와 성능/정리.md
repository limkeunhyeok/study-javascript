# you don't know js this와 객체 프로토타입, 비동기 성능

## Part 1 this와 객체 프로토타입

### 1. this라나 뭐라나

- this는 모든 함수 스코프 내에 자동으로 설정되는 특수한 식별자
- this는 작성 시점이 아닌 런타임 시점에 바인딩 되며 함수 호출 당시 상황에 따라 콘텍스트가 결정
- 함수 선언 위치와 상관없이 this 바인딩은 어떻게 함수를 호출했느냐에 정해짐

### 2. this가 이런 거로군

- this 바인딩은 함수의 직접적인 호출부에 따라 달라짐
- this 바인딩 우선순위
  - new로 호출했다면 새로 생성된 객체로 바인딩
  - call이나 apply 또는 bind로 호출됐다면 주어진 객체로 바인딩
  - 호출의 주체인 콘텍스트 객체로 호출됐다면 바로 이 콘텍스트 객체로 바인딩
  - 기본 바인딩에서 엄격 모드는 undefined, 그 밖엔 전역 객체로 바인딩
- 예기치 않게 기본 바인딩 규칙이 적용되는 경우를 조심해야 하며, 안전하게 하고 싶다면 DMZ 객체를 자리 끼움 값으로 바꿔 넣어 부수 효과가 전역 객체에서 발생하지 않도록 함
- ES6 화살표 함수는 표준 바인딩 규칙을 무시하고 렉시컬 스코프로 this를 바인딩
  - 에두른 함수 호출로부터 어떤 값이든 this 바인딩을 상속

### 3. 객체

- 자바스크립트 객체는 리터럴 형식과 생성자 형식의 형태가 있으며, 종종 생성 시 옵션을 주기 위해 생성자 형식을 쓰는 경우가 있음
- 객체는 6개의 원시 타입 중 하나고 함수를 비롯한 하위 타입이 있음(object array)
- 객체는 키/값의 쌍을 모아 놓은 저장소이고 값은 프로퍼티를 통해 접근할 수 있음
  - 접근 시 엔진 내부에서 [[GET]] 연산을 호출하며, 때로 [[Prototype]] 연쇄를 순회하며 찾음
- 프로퍼티는 프로퍼티 서술자를 통해 제어 가능한 writable, configurable 등의 특정한 속성을 가짐
  - `preventExtensions()`, `seal()`, `freeze()` 등 메서드를 통해 여러 단계의 불변성을 적용할 수 있음
- 프로퍼티가 반드시 값을 가져야 하는 것은 아니며 게터/세터로 접근자 프로퍼티 형태를 취할 수도 있음
- ES6부터는 `for ... of` 구문에서 한 번에 하나씩 다음 데이터값으로 이동하는 `next()` 메서드를 가진 내장/커스텀 @@iterator 객체를 통해 자료 구조에서 여러 값을 순회할 수 있음

### 4. 클래스와 객체의 혼합

- 클래스는 디자인 패턴의 일종이며, 자바스크립트도 유사한 구문이 있으나 다른 언어들과 다름
- 클래스는 복사를 의미
  - 클래스 -> 인스턴스로 복사
- 클래스를 상속하면 부모 -> 자식 방향으로 복사
- 자바스크립트는 객체 간 사본을 자동으로 생성하지 않음
- 명시적 믹스인은 클래스의 복사 기능과 같지 않으며, 단지 공유된 레퍼런스만 복사

### 5. 프로토타입

- 객체에 존재하지 않은 프로퍼티를 접근하려고 하면 [[Prototype]] 링크를 따라 순회
- 모든 일반 객체의 최상위 프로토타입 연쇄에는 내장 Object.prototype이 있으며 여기서도 발견되지 않으면 순회를 종료
- 두 객체를 연결 짓는 가장 일반적인 방법은 new 키워드를 사용하는 것
- 새로운 객체와 연결된 다른 객체는 new를 이용하여 호출한 함수의 .prototype으로 참조할 수 있음
  - new로 호출한 함수를 생성자라고 하며 다른 언어의 생성자와는 다름
- 자바스크립트 체계가 전통적인 클래스 지향 언어의 '클래스 인스턴스화 및 클래스 상속'과 유사해 보이지만 자바스크립트에서는 복사가 일어나지 않음
  - 객체는 결국 다른 객체와 내부 [[Prototype]] 연쇄를 통해 연결

### 6. 작동 위임

- 작동 위임 패턴은 객체를 부모/자식 클래스 관계가 아닌 동등한 입장에서 서로 위임하는 형태로 연결
- 객체만으로 구성된 코드를 구성한다면 사용 구문도 단순해질뿐더러 실제로 코드 아키텍처 또한 더 간단하게 가져갈 수 있음
- OLOO(Objects Linked to Other Objects)는 클래스라는 추상화 장치 없이도 직접 객체를 생성 및 연계하며, [[Prototype]] 기반의 작동 위임을 자연스럽게 구현

## Part 2 비동기와 성능

### 1. 비동기성: 지금과 나중

- 자바스크립트 프로그램은 2개 이상의 덩이로 쪼개지며 이벤트 응답으로 첫 번째 덩이는 '지금', 다음 덩이는 '나중'에 실행
  - 한 덩이씩 실행되어도 모든 덩이가 프로그램의 스코프/상태에 똑같이 접근할 수 있으므로 상태 변화는 차례대로 반영
- 이벤트 루프는 큐를 비울 때까지 실행
  - 이벤트 루프를 한 차례 순회하는 것을 틱이라 함
- 언제나 한 개의 이벤트만 큐에서 꺼내 처리하며 이벤트 처리 도중, 하나 또는 그 이상의 후속 이벤트를 직/간접적으로 일으킬 수 있음
- 동시성은 복수의 이벤트들이 연쇄적으로 시간에 따라 인터리빙 되면서 동시에 실행되는 것처럼 보임
- 동시 프로세스들은 어떤 형태로든 서로 영향을 미치는 작업을 조정하여 실행 순서를 보장하거나 경합 조건을 예방하는 등의 조치가 필요
- 프로세스 자체를 더 작은 덩이로 나누어 다른 프로세스에 인터리빙 되는 형태의 협동도 가능

### 2. 콜백

- 콜백은 자바스크립트에서 비동기성을 표현하는 기본 단위
- 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로 구현된 코드를 이해하기 어려움
- 콜백은 프로그램을 진행하기 위해 제어를 역전, 즉 제어권을 다른 파트(서드 파티 유틸리티)에 암시적으로 넘겨줘야 함
- 믿음성 문제를 해결하기 위해 임시 로직을 작성하면 당장은 모면할 수 있지만 유지 보수가 어려운 코드로 변질될 수 있음
  - 관용 코드를 여기저기 흩뿌리지 않고도 생성한 콜백들을 재사용할 수 있는 일반적인 해결 방안이 필요

### 3. 프로미스

- 프로미스는 제어의 역전 문제를 해결
- 프로미스가 콜백을 완전히 없애진 않지만, 기존 콜백 코드를 믿을 만한 중계자 역활을 수행하는 유틸리티를 통해 조정하여 서로 조화롭게 작동할 수 있도록 유도한 것
- 프로미스 연쇄는 비동기 흐름을 순차적으로 표현하는 방법

### 4. 제너레이터

- 제너레이터는 ES6부터 도입된 새로운 유형의 함수로, 일반 함수처럼 완전-실행하지 않고 실행 도중 멈출 수도 있고 멈춘 지점에서 나중에 다시 시작할 수도 있음
- 멈춤/재개가 번갈아 일어나므로 제너레이터는 선점적이라기보다 협동적인 툴
- yield 키워드를 통해 스스로 멈출 수 있고 이 제너레이터를 제어하는 이터레이터는 제너레이터를 다시 시작할 수 있음
- yield / `next()` 이중성은 제어 장치뿐 아니라 양방향 메시징 체계로도 실질적인 활용이 가능
  - yield는 일단 멈추고 `next()`는 yield 표현식에 값을 전해줌
- 비동기 흐름 제어와 연관된 제너레이터의 핵심은 내부 코드가 동기/순차적 형태로 일련의 작업 단계를 자연스럽게 표현할 수 있는 능력
  - yield가 잠재적인 비동기성이 있으며 이터레이터가 제어하는 코드로 비동기성을 옮겨놓은 것

### 5. 프로그램 성능

- 비동기 특성은 근본적으로 단일 이벤트 루프 스레드에 묶여 있어 한계가 있음
- 프로그램 수준에서 성능을 개선할 수 있는 체계
  - 웹 워커: 비동기성 이벤트를 이용하여 스레드 간에 메시지를 교환하면서 자바스크립트 파일을 개별 스레드 단위로 실행하게 해줌
  - SIMD: CPU 수준의 병렬 수학 연산을 대량 데이터의 수치 연산 같은 고성능 병렬 데이터 연산에 특화된 자바스크립트 API로 연결짓는 기법(18년 3월 WebAssembly를 위한 SIMD 제안이 진행됨에 따라 Candiate 단계에서 제거됨)
  - asm.js: 최적화하기 어려운 영역을 피해서 자바스크립트 엔진이 이런 부류의 코드를 자동 인식하여 공격적인 최적화를 하도록 유도하는 자바스크립트의 부분 집합

### 6. 벤치마킹과 튜닝

- 효과적으로 벤치마킹하려면
  - Benchmark.js를 사용
  - 되도록 다양한 환경에서 테스트 결과를 수집
  - 미세성능에 집착하지 말고, 임계 경로의 최적화 같은 넓은 시야에서 집중할 것
- 꼬리 호출 최적화(TCO)는 ES6부터 필수 최적화 구현 항목으로 자리잡았고 자바스크립트에서 다른 방법으론 불가능한 일부 재귀 패턴을 가능하게 함
