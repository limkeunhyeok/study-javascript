# Part 2 비동기와 성능

## Chapter 5 프로그램 성능

> 자바스크립트에서 비동기성이 중요한 이유는 성능 때문이다. 2개의 독립적인 AJAX 요청이 있을 때 순차(Serial), 동시(Concurrent) 두 가지 방법으로 모델링할 수 있다. 첫 번째 요청을 하고 완료되면 두 번째 요청을 시작하거나(순차), 프로미스/제너레이터처럼 두 요청을 병렬 전송한 뒤 둘 다 관문을 통과할 떄까지 잠시 대기한 후 진행하는(동시) 두 가지 방법이 있다. 동시에 모델링 하는 것이 순차에 비해 성능이 훨씬 좋으며 사용자 경험(User eXperience) 측면에서도 낫다.

### 1. 웹 워커

<p>
    자바스크립트는 싱글 스레드로 동작하지만 웹 워커를 사용하면 브라우저에서 멀티스레드로 활용할 수 있다. 브라우저 같은 환경은 다수의 자바스크립트 엔진 인스턴스를 쉽게 내어줄 수 있고 인스턴스마다 개별 스레드를 배정하여 실행할 수도 있다. 이러한 프로그램의 독립적인 스레드 조각을 워커라고 하는데 프로그램을 덩이로 나누어 병렬 실행하는 작업 병행성(Task Parallelism)을 추구한다. 자바스크립트 메인 프로그램에서 워크는 아래와 같이 인스턴스화 한다.
</p>

```javascript
var w1 = new Worker("http://some.url.1/mycoolworker.js");
```

<p>
    URL로 실행한 워커는 전용 워커(Dedicated Worker)라고 하며, Blob URL로 인라인 워커를 생성하는 방법도 있다. 워커로 읽어들일 자바스크립트 파일의 URL을 지정하면 브라우저는 이 파일을 별도의 스레드에서 독립적인 프로그램으로 실행한다. 워커는 같은 워커끼리, 심지어는 메인 프로그램과도 스코프 및 자원을 공유하지 않지만 기본적인 이벤트 메시징 체계를 바탕으로 서로 연결한다.
</p>

```javascript
// 워커 객체 w1: 이벤트 리스너 + 트리거
// 메인 js
w1.addEventListener("메시지", function(evt) { /*evt.data*/ });
w1.postMessage("재미난 얘기");
```

```javascript
// 워커 내부 메시징 구조도 대칭적(Symmetrical)
// mycoolworker.js
addEventListener("메시지", function(ev) { /*ev.data*/ });
postMessage("쿨한 대답");
```

<p>
    전용 워커는 자신을 만든 프로그램과 1:1 관계 이므로, 메시지 이벤트를 구별할 필요는 없다. 워커는 필요시 자신의 자식 워커들을 만들 수 있다.(subworkers) 세부 로직은 마스터 워커에게 넘기고, 작업을 단계별로 처리할 다른 워커를 생성하도록 위임하는 것이 가능하다. 워커를 낳은 프로그램은 이 워커 객체를 terminate()으로 제거한다. 브라우저에서 다수의 페이지가 같은 파일 URL로부터 워커를 생성하려 하면 각 페이지는 별개의 워커로 동작한다.
</p>

#### 워커 환경

<p>
    워커 내부에서는 메인 프로그램의 자원에 접근할 수 없다. 전역 변수는 물론이고 페이지 DOM 등 여타 자원도 접근할 수 없다. 하지만 워커는 네트워크 작업과 타이머 설정이 가능하며 중요한 전역 변수/특성을 자체 복사하여 접근할 수 있다. 워커에 추가 자바스크립트를 읽어 들이려면 importScripts()를 사용하면 된다. 스크립트는 동기적으로 실행하므로, 해당 파일 처리가 완료될 때까지 나머지 워커 코드는 중지된다. 웹 워커의 주요 용도는 다음과 같다.
</p>

- 처리 집약적 수학 계산
- 대용량 데이터 세트 정렬
- 데이터 작업 (압축, 오디오 분석, 이미지 픽셀 변환)
- 트래픽 높은 네트워크 통신

#### 데이터 전송

<p>
    웹 워커는 이벤트 체계를 바탕으로 스레드간 대량의 데이터가 양방향 전송되어야 한다. 어떤 객체를 전달하면 수신측에서는 구조화된 복제 알고리즘(Structured Clone Algorithm)으로 객체를 복사/복제한다. 이 알고리즘은 상당히 정교해서 환형 참조(Circular Reference) 객체도 복제할 수 있다. 객체와 문자열 변환 비용은 어쩔 수 없지만 이 알고리즘을 쓰면 메모리에 사본을 둘 수 있다.
</p>

<p>
    데이터 세트 규모가 방대하면 트랜스퍼러블 객체를 고려하는 것이 좋다. 데이터 자체는 그대로 두고 객체의 소유권만 전송하는 방식이다. 어떤 객체가 워커로 변신하고 나면 원래 위치에서는 텅 빈, 접근할 수 없는 객체가 되기 때문에 공유 스코프에서의 위험 요소를 제거할 수 있다. 물론 소유권 전송은 양방향 모두 가능하다. 트랜스퍼러블 객체를 지원하지 않는 브라우저에서는 어쩔 수 없이 구조화된 복제(Structured Cloning)를 해야 하는데 특성이 아주 파괴되지는 않지만 성능 저하는 피할 수 없다.
</p>

#### 공유 워커

<p>
    같은 페이지에 탭을 여러 개 읽어들이는 웹 사이트/앱에서는 마땅히 전용 워커가 중복되는 걸 최대한 방지하여 시스템 자원 점유율을 낮춰야 한다. 가장 흔한 자원 제약은 네트워크 소켓 접속으로, 브라우저가 단일 호스트에 동시 접속할 수 잇는 개수 제한을 말한다. 물론, 단일 클라이언트의 다중 접속 제한은 서버 자원 요건을 완화시키는데 도움이 된다. 이 경우 웹사이트와 앱의 페이지 인스턴스가 서로 공유할 수 있는 하나의 중앙 워커를 두는 것이 좋다. SharedWorker가 바로 그러한 중앙 워커이며 생성 방법은 아래와 같다.
</p>

```javascript
var w1 = new SharedWorker("http://some.url.1/mycoolworker.js");
```

<p>
    공유 워커는 다수의 프로그램 인스턴스/페이지와 연결 가능한 관계로 메시지 출처가 어느 프로그램인지 파악할 방법이 필요하다. 그래서 port라는 고유 식별자가 있다. 호출 프로그램은 워커의 port 객체를 통하여 통신한다.
</p>

```javascript
w1.port.addEventListener("message", handleMessages);
// ...
w1.port.postMessage("something cool");
```

<p>
    포트 연결은 반드시 초기화해야 한다. 공유 워커 내부에서는 connect라는 이벤트를 처리해야 하는데, 이 이벤트는 특정 연결에 관한 포트 객체를 제공한다.
</p>

<p>
    포트 접속이 끊겨도 다른 포트 접속이 살아있으면 공유 워커는 지속되지만 전용 워커는 자신을 초기화한 프로그램이 종료되면 자취를 감춘다. 하지만 기본적으로 공유 워커와 전용 워커의 기능과 의도는 같다.
</p>
