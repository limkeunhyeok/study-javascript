# Part 2 비동기와 성능

## Chapter 5 프로그램 성능

> 자바스크립트에서 비동기성이 중요한 이유는 성능 때문이다. 2개의 독립적인 AJAX 요청이 있을 때 순차(Serial), 동시(Concurrent) 두 가지 방법으로 모델링할 수 있다. 첫 번째 요청을 하고 완료되면 두 번째 요청을 시작하거나(순차), 프로미스/제너레이터처럼 두 요청을 병렬 전송한 뒤 둘 다 관문을 통과할 떄까지 잠시 대기한 후 진행하는(동시) 두 가지 방법이 있다. 동시에 모델링 하는 것이 순차에 비해 성능이 훨씬 좋으며 사용자 경험(User eXperience) 측면에서도 낫다.

### 1. 웹 워커

<p>
    자바스크립트는 싱글 스레드로 동작하지만 웹 워커를 사용하면 브라우저에서 멀티스레드로 활용할 수 있다. 브라우저 같은 환경은 다수의 자바스크립트 엔진 인스턴스를 쉽게 내어줄 수 있고 인스턴스마다 개별 스레드를 배정하여 실행할 수도 있다. 이러한 프로그램의 독립적인 스레드 조각을 워커라고 하는데 프로그램을 덩이로 나누어 병렬 실행하는 작업 병행성(Task Parallelism)을 추구한다. 자바스크립트 메인 프로그램에서 워크는 아래와 같이 인스턴스화 한다.
</p>

```javascript
var w1 = new Worker("http://some.url.1/mycoolworker.js");
```

<p>
    URL로 실행한 워커는 전용 워커(Dedicated Worker)라고 하며, Blob URL로 인라인 워커를 생성하는 방법도 있다. 워커로 읽어들일 자바스크립트 파일의 URL을 지정하면 브라우저는 이 파일을 별도의 스레드에서 독립적인 프로그램으로 실행한다. 워커는 같은 워커끼리, 심지어는 메인 프로그램과도 스코프 및 자원을 공유하지 않지만 기본적인 이벤트 메시징 체계를 바탕으로 서로 연결한다.
</p>

```javascript
// 워커 객체 w1: 이벤트 리스너 + 트리거
// 메인 js
w1.addEventListener("메시지", function(evt) { /*evt.data*/ });
w1.postMessage("재미난 얘기");
```

```javascript
// 워커 내부 메시징 구조도 대칭적(Symmetrical)
// mycoolworker.js
addEventListener("메시지", function(ev) { /*ev.data*/ });
postMessage("쿨한 대답");
```

<p>
    전용 워커는 자신을 만든 프로그램과 1:1 관계 이므로, 메시지 이벤트를 구별할 필요는 없다. 워커는 필요시 자신의 자식 워커들을 만들 수 있다.(subworkers) 세부 로직은 마스터 워커에게 넘기고, 작업을 단계별로 처리할 다른 워커를 생성하도록 위임하는 것이 가능하다. 워커를 낳은 프로그램은 이 워커 객체를 terminate()으로 제거한다. 브라우저에서 다수의 페이지가 같은 파일 URL로부터 워커를 생성하려 하면 각 페이지는 별개의 워커로 동작한다.
</p>

#### 워커 환경

<p>
    워커 내부에서는 메인 프로그램의 자원에 접근할 수 없다. 전역 변수는 물론이고 페이지 DOM 등 여타 자원도 접근할 수 없다. 하지만 워커는 네트워크 작업과 타이머 설정이 가능하며 중요한 전역 변수/특성을 자체 복사하여 접근할 수 있다. 워커에 추가 자바스크립트를 읽어 들이려면 importScripts()를 사용하면 된다. 스크립트는 동기적으로 실행하므로, 해당 파일 처리가 완료될 때까지 나머지 워커 코드는 중지된다. 웹 워커의 주요 용도는 다음과 같다.
</p>

- 처리 집약적 수학 계산
- 대용량 데이터 세트 정렬
- 데이터 작업 (압축, 오디오 분석, 이미지 픽셀 변환)
- 트래픽 높은 네트워크 통신

#### 데이터 전송

<p>
    웹 워커는 이벤트 체계를 바탕으로 스레드간 대량의 데이터가 양방향 전송되어야 한다. 어떤 객체를 전달하면 수신측에서는 구조화된 복제 알고리즘(Structured Clone Algorithm)으로 객체를 복사/복제한다. 이 알고리즘은 상당히 정교해서 환형 참조(Circular Reference) 객체도 복제할 수 있다. 객체와 문자열 변환 비용은 어쩔 수 없지만 이 알고리즘을 쓰면 메모리에 사본을 둘 수 있다.
</p>

<p>
    데이터 세트 규모가 방대하면 트랜스퍼러블 객체를 고려하는 것이 좋다. 데이터 자체는 그대로 두고 객체의 소유권만 전송하는 방식이다. 어떤 객체가 워커로 변신하고 나면 원래 위치에서는 텅 빈, 접근할 수 없는 객체가 되기 때문에 공유 스코프에서의 위험 요소를 제거할 수 있다. 물론 소유권 전송은 양방향 모두 가능하다. 트랜스퍼러블 객체를 지원하지 않는 브라우저에서는 어쩔 수 없이 구조화된 복제(Structured Cloning)를 해야 하는데 특성이 아주 파괴되지는 않지만 성능 저하는 피할 수 없다.
</p>

#### 공유 워커

<p>
    같은 페이지에 탭을 여러 개 읽어들이는 웹 사이트/앱에서는 마땅히 전용 워커가 중복되는 걸 최대한 방지하여 시스템 자원 점유율을 낮춰야 한다. 가장 흔한 자원 제약은 네트워크 소켓 접속으로, 브라우저가 단일 호스트에 동시 접속할 수 잇는 개수 제한을 말한다. 물론, 단일 클라이언트의 다중 접속 제한은 서버 자원 요건을 완화시키는데 도움이 된다. 이 경우 웹사이트와 앱의 페이지 인스턴스가 서로 공유할 수 있는 하나의 중앙 워커를 두는 것이 좋다. SharedWorker가 바로 그러한 중앙 워커이며 생성 방법은 아래와 같다.
</p>

```javascript
var w1 = new SharedWorker("http://some.url.1/mycoolworker.js");
```

<p>
    공유 워커는 다수의 프로그램 인스턴스/페이지와 연결 가능한 관계로 메시지 출처가 어느 프로그램인지 파악할 방법이 필요하다. 그래서 port라는 고유 식별자가 있다. 호출 프로그램은 워커의 port 객체를 통하여 통신한다.
</p>

```javascript
w1.port.addEventListener("message", handleMessages);
// ...
w1.port.postMessage("something cool");
```

<p>
    포트 연결은 반드시 초기화해야 한다. 공유 워커 내부에서는 connect라는 이벤트를 처리해야 하는데, 이 이벤트는 특정 연결에 관한 포트 객체를 제공한다.
</p>

<p>
    포트 접속이 끊겨도 다른 포트 접속이 살아있으면 공유 워커는 지속되지만 전용 워커는 자신을 초기화한 프로그램이 종료되면 자취를 감춘다. 하지만 기본적으로 공유 워커와 전용 워커의 기능과 의도는 같다.
</p>

### 2. SIMD

<p>
    SIMD(Single Instruction, Multiple Data)는 데이터 병행성을 나타내는 형식으로, 웹 워커의 작업 병행성과는 대조되는 개념이다. SIMD의 관심사는 프로그램 로직 덩이들을 병렬 실행하는 게 아니라 여러 데이터 비트를 병렬로 처리하는 일이다.
</p>

<p>
    SIMD는 스레드 병행성을 제공하지 않는다. 대신 현대 CPU는 숫자 벡터와 모든 숫자에 병렬 연산이 가능한 명령어 세트를 이용하여 SIMD 기능을 제공한다. SIMD 자바스크립트는 단축 벡터 타입과 API를 자바스크립트 코드의 일부분처럼 사용하는데, 이러한 SIMD 구동 시스템은 처리할 작업들을 CPU 동등체(Equivalents)로 직접 매핑한다. 병렬화하지 않은 작업은 SIMD 아닌(Non-SIME) 시스템에 심(Shim)하여 대체한다. 데이터 집약적 애플리케이션은 보통 수학 계산을 병렬로 처리하므로 뚜렷한 성능 향상을 기대할 수 있다.
</p>

<p>
    18년 3월 SIMD.js는 WebAssembly를 위한 SIMD 제안이 진행됨에 따라 Candiate 단계에서 제거되었다.
</p>

### 3. asm.js

<p>
    asm.js는 자바스크립트 언어에서 고도로 최적화 가능한 부분 집합을 말한다. 최적화하기 어려운, 특정한 특정한 체계와 패턴을 방지한 asm.js식 코드는 자바스크립트 엔진이 인식하여 공격적으로 저수준 최적화를 하는 등의 특별히 조치를 한다.
</p>

#### asm.js 최적화

<p>
    asm.js 최적화를 이해하려면 먼저 타입과 강제 변환을 알아야 한다. 자바스크립트 엔진이 다양한 연산 도중 상이한 타입의 변수 값들을 추적하면서 필요할 경우 타입 간 강제변환을 처리하는데 프로그램 최적화를 방해하는 잡다한 요소가 너무 많다.
</p>

<p>
    asm.js-인식형 자바스크립트 엔진이 변수/연산 타입을 추론할 수 있게 힌트를 주고 강제변환 추적 단계를 건너뛰도록 하는 몇 가지 수법이 있다.
</p>

```javascript
// 일반적인 할당 구문
var a = 42;
var b = a; // 할당 결과 변수 타입은 바뀔 수 있음

// asm.js
var a = 42;
var b = a | 0; // 정수 타입으로 강제 변환
```

#### asm.js 모듈

<p>
    메모리 할당, 가비지 콜렉션, 스코프 접근은 자바스크립트 성능 문제를 일으킨다. 그 해결 방안으로 asm.js에서는 더 정형화한 asm.js 모듈을 선언한다.
</p>

<p>
    asm.js 모듈은 단순히 렉시컬 스코프를 통해 전역 객체를 쓰는 대신 필요한 심볼을 가져오기 위해 엄격하게 규정된 네임스페이스를 분명히 전달한다. window 객체는 asm.js 모듈이 의도한 바와 잘 맞는 기본 stdlib 객체지만 더 제한된 객체를 만들수도 있다.
</p>

<p>
    또, 힙을 반드시 선언하고 전달해서 asm.js 모듈이 메모리 천(Memory Churn)을 일으키지 않고 사전 예약된 공간을 사용하도록 해야 한다.
</p>
