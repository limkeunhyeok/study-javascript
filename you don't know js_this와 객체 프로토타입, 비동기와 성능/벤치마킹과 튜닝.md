# Part 2 비동기와 성능

## Chapter 6 벤치마킹과 튜닝

### 1. 벤치마킹

<p>
    자바스크립트 성능 벤치마킹은 주어진 작업 실행 시간 동안 측정한 결과를 보고 무엇을 알 수 있는지, 무엇을 알 수 없는지부터 파악하는 게 기본이다. 소요 시간만으로는 작업을 딱 한 번 실행할 때 그만큼 시간이 걸린다는 정도만 알 수 있다. 늘 그 속도로 돌아가리란 보장이 없다. 엔진/시스템이 그때그때 어떤 식으로 간섭을 일으킬지 예측할 수 없고 더 빨리 실행되야 하는 경우도 있다. 소요 시간이 4로 나왔다고 했을 때, 정확히 4밀리 초가 걸렸다고 단정 지을 수 없다. start, end 타임 스탬프를 얻는 과정에서도 지연이 발생할 수 있어 실제로는 4밀리 초 이하일 것이다.
</p>

#### 반복

<p>
    단순 평균치만으로는 전체 애플리케이션의 성능에 관하여 어떤 결론도 내리기 어렵다. 100회 반복 테스트를 한다 해도 이상점이 2개만 있어도 평균은 왜곡될 수 있고 여기서 도출된 결론을 반복 적용하면 왜곡된 사실은 더욱 부풀려진다.
</p>

<p>
    오류 빈도를 최소화하려면 사용 중인 타이머의 정확도에 따라 반복 테스트 시간을 결정해야 한다. 부정확한 타이머일수록 테스트 시간을 늘려 가능한 한 에러를 줄여야 한다. 15밀리 초 타이머로는 정확히 벤치마킹하기 어렵다. 이 타이머로 불확실성을 1% 이하로 낮추려면 적어도 750밀리 초는 테스트해야 한다.
</p>

<p>
    하지만 단지 샘플일 뿐이다. 왜곡을 확실히 상쇄하려면 평균을 낼 샘플이 많아야 한다. 또 최악의 샘플은 얼마나 느린지, 최고의 샘플은 얼마나 빠른지 그리고 이 최악/최고 간 격차는 얼마인지 파악해야 한다. 어느 것이 얼마나 빠르다고 하는 수치뿐 아니라 이 수치를 어느 정도 신뢰할 수 있을지 판단의 근거가 되는 정량적 데이터도 필요하다.
</p>

#### Benchmark.js

<p>
    유의미한, 신뢰할 수 있는 벤치마킹은 반드시 통계적으로 검증된 지침에 근거한다. 존-데이빗 달튼과 마티아스 바이넨스가 Benchmark.js라는 통계학적으로 검증된 벤치마킹 도구를 발표하였다.
</p>

```javascript
// Benchmark.js

function foo() {
    // 테스트할 작업들
}

var bench = new Benchmark(
    "foo text", // 테스트 명
    foo, // 테스트할 함수
    {
        // 추가 옵션
    }
);

bench.hz; // 초당 작업 개수
bench.stats.moe; // 한계 에러
bench.stats.variance; // 분산
```

<p>
    Benchmark.js는 브라우저 환경의 자바스크립트 테스팅에 주로 쓰지만 브라우저 이외의 환경에서도 사용할 수 있다.
</p>

### 2. 콘텍스트가 제일

<p>
    X, Y 작업 간 성능 비교 등 특정한 성능 벤치마킹을 할 때 콘텍스트를 살피는 걸 잊으면 안된다. 테스트 결과, X가 Y보다 빠른 것처럼 나왓다고 해서 쉽게 결론을 내릴 수 없다.
</p>

#### 엔진 최적화

<p>
    고립 테스트 결과, X가 Y보다 10밀리 초 빨랐다고 단순히 X는 Y보다 항상 빠를 것이라고 넘겨짚는 건 위험한 발상이다. 사실 성능은 다루기가 아주 까다롭다. 예를 들어 아래는 미세 성능을 테스트하는 코드이다.
</p>

```javascript
var twelve = "12";
var foo = "foo";

// 테스트 1
var X1 = parseInt(twelve);
var X2 = parseInt(foo);

// 테스트 2
var Y1 = Number(twelve);
var Y2 = Number(foo);
```

<p>
    `Number()`와는 다르게 `parseInt()`가 어떻게 작동할지는 `parseInt()` 인자가 foo인 경우 필경하는 일이 더 많거나 아니면 두 함수 모두 첫 번째 문자 'f'에서 멈출 테니 작업량은 엇비슷할 것으로 추측할 것이다. 사실 내부에서 무슨 일이 벌어질지 알 수 없으며, 추측만 무성할 뿐 확실한 결정을 내릴 만한 구체적인 증거는 없다. 실제 코드가 아닌 테스팅만으로 실제 결과를 알 수 없다.
</p>

### 3. jsPerf.com

<p>
    Benchmark.js는 자바스크립트 실행 환경에 구애받지 않고 코드 성능을 테스트할 수 있는 유용한 도구지만 신뢰할 수 있는 결론을 원한다면 다양한 환경에서 테스트한 결과를 취합해야 한다. 예를 들어 고성능 데스크탑의 크롬과 스마트폰의 크롬은 성능이 당연히 차이날 수 밖에 없으며, 배터리가 100%인 스마트폰과 2%인 스마트폰이 같은 성능을 보일 순 없다.
</p>

<p>
    다수의 환경에서 X가 Y보다 빠르다고 결론을 내리려면 다양한 환경에서 테스트해야 한다. 크롬에서 빠르다고 다른 브라우저에서도 빠르다고 할 수는 없으며, 때때로 실 사용자를 대상으로 멀티 브라우저 테스트한 결과를 상호 참조해야 할 수도 있다.
</p>

<p>
    jsPerf가 이러한 목적으로 개발된 웹 사이트로, 접속 가능한 공개 URL에 대하여 Benchmark.js 라이브러리를 이용하여 통계적으로 정확하고 믿음성 있는 테스트를 대행한다. 테스트를 할 때마다 결과를 수집/저장하고 다른 사람도 볼 수 있도록 누적 테스트 결과를 그래프로 보여준다.
</p>

#### 정상 테스트

```javascript
// 케이스 1
var x = [];
for (var i = 0; i < 10; i++) {
    x[i] = "x";
}

// 케이스 2
var x = [];
for (var i = 0; i < 10; i++) {
    x[x.length] = "x";
}

// 케이스 3
var x = [];
for (var i = 0; i < 10; i++) {
    x.push("x");
}
```

- 위와 같은 테스트 시나리오가 있을 때 따져봐야 할 항목
  - Benchmark.js가 필요 시 반복을 대신하며, 루프를 직접 넣을 필요는 없다.
  - 테스트 케이스마다 x를 선언/초기화할 필요는 없다.
  - 위의 테스트는 `x.length`, `x.push`가 배열에 원소를 추가할 때 성능에 얼마나 영향을 끼치는지 알아내는 테스트이며, `push()`는 함수 호출이므로 케이스 1, 2가 3보다는 빠를 것이다.
