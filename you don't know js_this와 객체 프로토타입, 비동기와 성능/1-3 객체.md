# Part 1 this와 객체 프로토타입

## Chapter 3 객체

### 1. 구문

<p>
    객체는 선언적(Declarative) 형식과 생성자 형식, 두 가지로 정의한다. 두 형식 모두 결과적으로 생성되는 객체는 같다. 차이점은 리터럴 형식은 한 번의 선언으로 다수의 키/값 쌍을 프로퍼티로 추가할 수 있지만, 생성자 형식은 한 번에 한 프로퍼티만 추가할 수 있다.
</p>

### 2. 타입

- 자바스크립트 객체의 7개 주요 타입
    1. null
    2. undefined
    3. boolean
    4. number
    5. string
    6. object
    7. symbol

<p>
    단순 원시 타입(string, number, boolean, null, undefined)은 객체가 아니다. 반면 복합 원시 타입이라는 독특한 객체 하위 타입이 있다. function은 객체의 하위 타입이다. 자바스크립트 함수는 기본적으로는 객체이므로 일급(First Class)이며 여타의 일반 객체와 똑같이 취급된다. 배열 역시 추가 기능이 구현된 객체의 일종이다. 다른 일반 객체보다 좀 더 조직적으로 데이터가 구성되는 특징이 있다.
</p>

#### 내장 객체

<p>
    내장 객체라고 부르는 객체 하위 타입도 있다. 일부는 단순 원시 타입과 직접 연관되어 보이지만 실제 관계는 뜻밖에 복잡하다.
</p>

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

<p>
    위의 리스트는 단지 자바스크립트의 내장 함수일 뿐 각각 생성자로 사용되어 주어진 하위 타입의 새 객체를 생성한다.
</p>

```javascript
var strPrimitive = '문자열';
console.log(typeof strPrimitive); // string
console.log(strPrimitive instanceof String); // false

var strObject = new String('문자열');
console.log(typeof strObject); // object
console.log(strObject instanceof String); // true

console.log(Object.prototype.toString.call(strObject)); // [object String]
```

<p>
    원시 값은 객체가 아닌 원시 리터럴이며 불변값이다. 문자 개수를 세는 등 문자별로 접근할 때는 String 객체가 필요하다. 자바스크립트 엔진은 상황에 맞게 문자열 원시 값을 String 객체로 자동 강제변환하므로 명시적으로 객체를 생성할 일은 거의 없다. 되도록 생성자 형식은 지양하고 리터럴 형식을 권장한다.
</p>

<p>
    Objects, Arrays, Functions, RegExps는 형식과 무관하게 모두 객체다. 생성자 형식은 리터럴 형식보다 옵션이 더 많은 편이다. 어느 쪽이든 결국 생성되는 객체는 같으므로 좀 더 간단한 리터럴 형식을 더 많이 쓴다.
</p>

<p>
    Error 객체는 예외가 던져지면 알아서 생성되니 명시적으로 생성할 일은 드물다. 생성자 형식 `new Error()`로 생성은 가능하지만 거의 쓸 일이 없다.
</p>

### 3. 내용

<p>
    객체는 특정한 위치에 저장된 모든 타입의 값, 즉 프로퍼티로 내용이 채워진다. 엔진이 값을 저장하는 방식은 구현 의존적(Implementation-Dependent)인데, 이는 객체 컨테이너에 담지 않는 게 일반적이다. 객체 컨테이너에는 실제로 프로퍼티 값이 있는 곳을 가리키는 포인터 역활을 담당하는 프로퍼티명이 담겨 있다.
</p>

<p>
    객체의 값에 접근하려면 '.' 또는 '[]' 연산자를 사용한다. '.' 구문을 프로퍼티 접근, '[]' 구문을 키 접근이라고 한다. '.' 연산자는 뒤에 식별자 호환(Identifier-Compatible) 프로퍼티명이 와야 하지만 '[]' 구문은 UTF-8/유니코드 호환 문자열이라면 모두 프로퍼티명으로 쓸 수 있다. 객체 프로퍼티명은 언제나 문자열이다. 문자열 이외의 다른 원시 값을 쓰면 우선 문자열로 변환된다.
</p>

#### 계산된 프로퍼티명

<p>
    ES6부터는 계산된 프로퍼티명(Computed Property Names)이라는 기능이 추가됐는데, 객체 리터럴 선언 구문의 키 이름 부분에 해당 표현식을 넣고 []로 감싸면 된다.
</p>

```javascript
var prefix = "foo";
var myObject = {
    [prefix + "bar"]: "hello",
    [prefix + "baz"]: "world"
}

console.log(myObject["foobar"]); // hello
console.log(myObject["foobaz"]); // world
```

#### 프로퍼티 vs 메서드

<p>
    객체에 존재하는 프로퍼티에 접근할 때마다 반환 값 타입에 상관없이 항상 프로퍼티 접근을 하고 이런 식으로 함수를 가져왔다고 해서 저절로 함수가 메서드가 되는 건 아니다. 프로퍼티 접근 결과 반환된 함수 역시 마찬가지다.
</p>

```javascript
function foo() {
    console.log("foo");
}

var someFoo = foo; // 'foo'에 대한 변수 레퍼런스

var myObject = {
    someFoo: foo
};

foo; // function foo() {...}
someFoo; // function foo() {...}
myObject.someFoo; // function foo() {...}
```

<p>
    `someFoo`나 `myObjcet.someFoo` 모두 같은 함수를 가리키는 개별 레퍼런스일 뿐, 특별한 다른 객체가 소유한 함수라는 의미는 아니다. `foo()` 안에 this 레퍼런스가 정의되어 있다면 `myObject.someFoo`에서 발생할 암시적 바인딩이 두 레퍼런스의 유일한 차이점이다. 결론은 자바스크립트에서 함수와 메서드란 말은 서로 바꿔 사용할 수 있다.
</p>

<p>
    ES6부터는 super 레퍼런스가 더해져서 class와 함께 사용할 수 있다. this 같은 뒤늦은 바인딩이 아닌 정적 바인딩 방식으로 작동하므로 함수보다는 메서드에 더 가까운 super 바인딩 함수라는 사상을 강조하지만 의미상, 체계상의 미묘한 차이가 있다.
</p>

```javascript
var myObject = {
    foo: function() {
        console.log("foo");
    }
};

var someFoo = myObject.foo;

someFoo; // function foo() {...}
myObject.foo; // function foo() {...}
```

<p>
    위의 코드처럼 함수 표현식을 객체 리터럴의 한 부분으로 선언해도 이 함수가 저절로 객체에 달라붙은 건 아니며 해당 함수 객체를 참조하는 레퍼런스가 하나 더 생기는 것 뿐이다.
</p>

#### 배열

<p>
    배열도 []로 접근하는 형태이며 값을 저장하는 방법과 장소가 체계적이다. 배열은 숫자 인덱싱, 즉 인덱스라는 양수로 표기된 위치에 값을 저장한다. 인덱스는 양수지만 배열 자체는 객체여서 배열에 프로퍼티를 추가할 수 있다. 하지만 프로퍼티를 추가해도 배열 길이에는 변함 없다.
</p>

```javascript
var myArray = ["foo", 42, "bar"];
console.log(myArray.length); // 3

myArray.baz = "baz"
console.log(myArray.length); // 3
console.log(myArray.baz); // baz
```

<p>
    위의 코드처럼 일반적인 키/값 객체로 배열을 사용할 수도 있지만 정해진 용도에 맞게 최적화되어 작동하므로 사용하지 않는 것이 좋다. 용도에 맞게 키/값 저장소로는 객체, 숫자 인덱스를 가진 저장소로는 배열을 쓰는 것이 좋다. 배열에 프로퍼티를 추가할 때 프로퍼티명이 숫자와 유사하면 숫자 인덱스로 잘못 해석되어 배열 내용이 달라질 수 있으므로 주의한다.
</p>
