# Part 1 this와 객체 프로토타입

## Chapter 4 클래스와 객체의 혼합

### 1. 클래스 이론

<p>
    클래스와 상속은 특정 형태의 코드와 구조를 형성하며 실생활 영역의 문제를 소프트웨어로 모델링 하기 위한 방법이다. 객체 지향 또는 클래스 지향 프로그래밍에서 데이터는 자신을 기반으로 하는 실행되는 작동(Behavior)과 연관되므로 데이터와 작동을 함께 잘 감싸는(캡슐화) 것이 올바른 설계라고 강조한다. 정규 컴퓨터 과학에서는 이를 자료구조란 말로 표현하기도 한다.
</p>

<p>
    클래스는 특정 자료 구조를 분류하는 용도로 쓴다. 즉, 일반적인 기준 정의에서 세부적이고 구체적인 변형으로서의 자료 구조를 도출하는 것이다. Vehicle 클래스와 Car 클래스가 있다고 할 때, Vehicle 한 곳에만 정의해두고 Car는 Vehicle에 있는 기반 정의(Base Definition)를 상속(Inherit) 받아 정의한다. Car가 일반적인 Vehicle의 정의를 세분화(Specialize)한 셈이다.
</p>

<p>
    다형성(Polymorphism)은 또 다른 클래스의 핵심 개념으로 부모 클래스에 뭉뚱그려 정의된 작동을 자식 클래스에서 좀 더 구체화하여 오버라이드(재정의)하는 것을 뜻한다. 오버라이드된 작동(Overridden Behavior)에서 기반 작동을 참조할 수 있는 건 이런 상대적 다형성(Relative Polymorphism) 때문이다.
</p>

#### 클래스 디자인 패턴

<p>
    절차적 프로그래밍(Procedural Programming)은 상위 수준의 추상화 없이 다른 함수를 호출하는 프로시저(Procedure)로만 코드를 구성하는 프로그래밍 기법이다. 절차적 프로그래밍 스타일로 작성된 스파게티 코드(복잡한)를 잘 정돈된 체계적인 코드로 전환하는 데 클래스가 바로 최적의 솔루션이라고 말하는 사람들이 있다. 그 외에도 클래스는 여러 디자인 패턴에서 많이 쓰인다.
</p>

#### 자바스크립트 클래스

<p>
    ES6부터 class라는 키워드가 명세에 정식으로 추가됐다. 클래스는 디자인 패턴이므로 자바스크팁트에서 고전적인 클래스 기능과 얼추 비슷하게 구현할 수 있다. 하지만 클래스처럼 보이는 구문일 뿐이며 클래스 디자인 패턴으로 코딩할 수 있도록 자바스크립트 체계를 억지로 고친 것에 불과하고 전혀 다른 방식으로 작동한다. 결론은 클래스는 소프트웨어 디자인 패턴 중 한 가지 옵션일 뿐, 클래스 사용 여부는 자신이 결정할 문제이다.
</p>

### 2. 클래스 체계

#### 건축

<p>
    클래스와 인스턴스 중심의 사고방식은 흔히 건축 현장에 빗대어 생각할 수 있다. 아키텍트는 건축의 모든 특성을 기획한다. 이 때 부품들을 배치할 전체적인 구조만 계획한다. 아키텍처 청사진은 건축을 위한 계획일 뿐, 청사진만으로 사람이 들어와서 않고 할 건물을 만들어낼 수는 없다. 실제로 건물을 올리는 작업은 시공사에 의뢰해야 하는데 일감을 수주받은 시공사는 정확히 청사진에 따라 건물을 짓는다. 완공된 건물은 청사진의 물리적인 인스턴스이며, 건물과 청사진의 관계는 간접적이다. 직접 살펴봐야 알 수 있는 부분에 대해선 부족함을 느낄 수밖에 없다.
</p>

<p>
    클래스가 바로 청사진에 해당한다. 개발자가 상호 작용할 실제 객체는 클래스라는 붕어빵 틀에서 구워낸다(인스턴스화한다). 이 구워냄의 최종 결과가 인스턴스라는 객체고 개발자는 객체 메서드를 직접 호출하거나 공용 데이터 프로퍼티에 접근한다. 객체는 클래스에 기술된 모든 특성을 그대로 가진 사본이다. 객체 인스턴스를 통해 클래스에 접근하여 어떤 조작을 가할 일은 거의 없지만 적어도 어느 클래스로부터 구워진 객체 인스턴스인지 그 출처를 식별하는 일은 어렵지 않다.
</p>

#### 생성자

<p>
    인스턴스는 보통 클래스명과 같은 이름의 생성자라른 특별한 메서드로 생성한다. 생성자의 임무는 인스턴스에 필요한 정보를 초기화하는 일이다.
</p>

```javascript
// 작동하는 코드는 아님!
class CoolGuy {
    specialTrick = nothing

    CoolGuy(trick) {
        specialTrick = trick
    }

    showOff() {
        output('나의 장기: ', specialTrick)
    }
}

// CoolGuy 인스턴스를 생성하려면 클래스 생성자를 호출한다
Joe = new CoolGuy('카드 마술');
Joe.showOff(); // 나의 장기: 카드 마술
```

<p>
    CoolGuy 클래스엔 생성자 `CoolGuy()`가 있어서 `new CoolGuy()`를 하면 실제로 이 생성자가 호출된다. 생성자의 반환 값은 객체이므로 `showOff()` 메서드를 호출할 수 있다.
</p>

<p>
    생성자는 클래스에 속한 메서드로, 클래스명과 같게 명명하는 것이 일반적이다. 그리고 새로운 클래스 인스턴스를 생성할 거라는 신호를 엔진이 인지할 수 있도록 항상 new 키워드를 앞에 붙여 생성자를 호출한다.
</p>

### 3. 클래스 상속

<p>
    클래스 지향 언어에서는 자체로 인스턴스화할 수 있는 클래스는 물론이고 첫 번째 클래스를 상속받은 두 번째 클래스를 정의할 수 있다. 이때 첫 번째 클래스를 부모 클래스, 두 번째 클래스를 자식 클래스라고 통칭한다. 자식 클래스는 부모 클래스에서 완전히 떨어진 별개의 클래스로 정의된다. 부모로부터 복사된 초기 버전의 작동을 고스란히 간직하고 있지만 물려받은 작동을 전혀 새로운 방식으로 오버라이드할 수 있다.
</p>

```javascript
// 작동하는 코드는 아님!
class Vehicle {
    engines = 1

    ignition() {
        output('엔진을 켠다.')
    }

    drive() {
        ignition();
        output('방향을 맞추고 앞으로 간다.')
    }
}

class Car inherits Vehicle {
    wheels = 4

    drive() {
        inherited:drive()
        output(wheels, '개의 바퀴로 굴러간다!')
    }
}

class SpeedBoat inherits Vehicle {
    engines = 2

    ignition() {
        output(engines, '개의 엔진을 켠다.')
    }

    pilot() {
        inherited:drive()
        output('물살을 가르며 쾌속으로 질주한다!')
    }
}
```

<p>
    Vehicle 클래스에는 엔진 하나와 시동 거는 방법, 주행 방법이 정의되어 있다. 하지만 아직 만들지도 않은 탈것에 불과하니 현시점에선 단지 추상적인 개념에 지나지 않는다. 구체적인 탈 것 차(Car)와 모터보트(Speedboat)를 정의한다. 둘 다 Vehicle의 일반적인 특성을 물려받아 각자에게 맞는 특성을 세분화한다. 위의 코드처럼 자동차는 4개의 바퀴가 필요하고 모터보트는 2개의 엔진이 필요하며, 시동 거는 방법도 내용이 추가되어야 한다.
</p>
