# Part 2 비동기와 성능

## Chapter 2 콜백

> 어떤 경우든 함수는 콜백 역활을 한다. 큐에서 대기 중인 코드가 처리되자마자 본 프로그램으로 되돌아올 목적지기 때문이다. 콜백은 자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자, 사실상 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다. 무수히 많은 정교하고 복잡한 자바스크립트 프로그램이 콜백으로 개발됐다.

### 1. 연속성

```javascript
// A
ajax("..", function(..) {
    // C
});
// B
```

<p>
    A와 B는 프로그램 전반부, C는 프로그램 후반부에 해당한다. 전반부 코드가 실행되면 비결정적(Indeterminate) 시간 동안 중지되고 언젠가 AJAX 호출이 끝날 때 중지되기 이전 위치로 다시 돌아와서 나머지 후반부 프로그램이 이어진다. 다시 말해, 콜백 함수는 프로그램의 연속성(Continuation)을 감싼(Wrapping)/캡슐화(Encapsulation)한 장치다.
</p>

### 2. 두뇌는 순차적이다

<p>
    키보드를 입력하면서 전화 통화를 하는 것처럼, 멀티태스킹을 하는 것처럼 보이는 상황도 사실 아주 재빠른 콘텍스트 교환기(Context Switcher)처럼 행동하고 있을 뿐이다. 다시 말해 여러 작업 사이를 재빨리 연속적으로 왔다 갔다 하면서 각 작업을 아주 작고 짧은 덩이로 쪼개어 동시에 처리하는 것이다.
</p>

#### 실행 vs 계획

<p>
    비동기 코드 작성이 어려운 이유는 인간이 비동기 흐름을 생각하고 떠올리는 일 자체가 부자연스럽기 때문이다. 인간은 단계별(Step-by-Step)로 끊어 생각하는 경향이 있는데, 동기 -> 비동기로 전환된 이후론 단계별로 나타내기가 쉽지 않다.
</p>

#### 중첩/연쇄된 콜백

```javascript
listen("click", function handler(evt) {
    setTimeout(function request() {
        ajax("http://some.url.1", function response(text) {
            if (text == "hello") {
                handler();
            } else if (text == "world") {
                request();
            }
        });
    }, 500);
});
```

<p>
    위의 코드는 비동기 단계를 3개의 함수가 서로 중첩된 형태이며, 콜백 지옥(Callback Hell) 또는 운명의 피라미드(Pyramid of Doom)라고 불리는 코드다. 언뜻 보면 이 코드 자체의 비동기성은 순차적 두뇌 계획(Brain Planning)과 자연스럽게 조화되는 것처럼 보인다.
</p>

```javascript
// 지금
listen("..", function handler(..) {
    // ..
});

// 나중
setTimeout(function request(..) {
    // ..
}, 500);

// 더 나중
ajax("..", function response(..) {
    // ..
});

// 결국
if (..) {
    // ..
}
else ..
```

<p>
    이런 식의 선형적인 코드 추론에는 몇 가지 문제점이 있다. 단순히 순차 실행될 경우는 많은 경우의 수 중 하나에 불과하다. 실제 비동기 자바스크립트 프로그램에는 갖가지 잡음(Noise)이 섞인다. 콜백으로 가득한 코드의 비동기 흐름을 이해하는 일은 연습/훈련을 반복해도 자연스럽고 쉽게 이해할만한 일은 아니다.
</p>

```javascript
doA(function() {
    doB();

    doC(function() {
        doD();
    })

    doE();
});

doF();
```

<p>
    위 코드의 실행 순서는 `doA() -> doF() -> doB() -> doC() -> doE() -> doD()`이다. 만일 A나 C가 비동기 코드가 아니라면 실행 순서는 `A -> B -> C -> D -> E -> F` 순으로 실행된다. 중첩 없이 이벤트/타임아웃/AJAX 예제를 다시 쓰면 다음과 같다.
</p>

```javascript
listen("click", handler);

function handler() {
    setTimeout(request, 500);
}

function request() {
    ajax("http://some.url.1", response);
}

function response(text) {
    if (text == "hello") {
        handler();
    } else if (text == "world") {
        response();
    }
}
```

<p>
    중첩/들여쓰기로 도배했던 앞선 코드보다 알아보기는 훨씬 편하다. 하지만 콜백 지옥에 취약한 건 마찬가지다. 선형적으로 이 코드를 추론하자면 최고의 경우를 가정한 단순한 코드다. 비동기 코드는 터무니없게 뒤죽박죽 뒤섞인 경우가 드물다.
</p>

<p>
    원하는 순으로 연결하여 연속 실행하고 싶을 때 하드 코딩을 사용할 수도 있다. 하지만 하드 코딩은 기본적으로 부실한 코드를 양산하기에 단계가 나아가는 도중 오류가 나는 것까지 대비할 수는 없다. 수작업으로 하드 코딩한 콜백은 대부분 바람직하지 않다. 만일의 사태와 가능한 경우의 수를 죄다 나열하다간 코드가 너무 복잡해져 버려 관리 및 수정이 난처해진다.
</p>
