# you don't know js 타입과 문법, 스코프와 클로저

## Part 1 타입과 문법

### 1. 타입

- 자바스크립트 7가지 타입
  - null
  - undefined
  - boolean
  - number
  - string
  - object
  - symbol
- 값이 없는 vs 선언되지 않은
  - undefined는 선언된 변수에 할당할 수 있는 값
  - undeclared는 변수 자체가 선언된 적이 없음
  - 자바스크립트는 두 경우 모두 에러 메시지 뿐만 아니라 typeof 반환 값도 undefined를 반환

### 2. 값

- 배열은 모든 타입의 값들을 숫자로 인덱싱한 집합
- 문자열은 유사 배열
- 자바스크립트에서 숫자는 정수와 부동 소수점 숫자 모두 포함
- null 타입은 null 값, undefined 타입은 undefined 값 하나만 있음
- undefined는 할당된 값이 없다면 모든 변수/프로퍼티의 디폴트 값
- void는 어떤 값이라도 undefined로 만듬
- 숫자의 특수 값
  - NaN
  - +Infinity
  - -Infinity
  - -0
- 단순 스칼라 원시 값은 값-복사에 의해, 합성 값은 레퍼런스-복사에 의해 값이 할당/전달

### 3. 네이티브

- 자바스크립트는 원시 값을 감싸는 객체 래퍼, 네이티브를 제공
- 객체 래퍼는 타입별로 쓸 만한 기능이 구현되어 있음
- 단순 스칼라 원시 값이 있을 때, 자바스크립트는 자동으로 원시 값을 박싱(해당되는 객체 래퍼로 감싼다)

### 4. 강제변환

- 강제변환은 알고 사용하면 유용
- 명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 명확한 것으로 혼동의 여지를 줄이고 가독성 및 유지 보수성을 높임
- 암시적 강제변환은 숨겨진 로직에 의한 부수 효과가 있으며 변환이 처리되는 과정이 명확하지 않음
  - 오히려 가독성을 향상
  - 변환 과정을 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 함

### 5. 문법

- 문과 표현식은 영어 언어의 문장, 어구와 각각 유사하며, 표현식은 순수하고 독립적이지만 부수 효과를 일으킬 수 있음
- 자바스크립트 문법에는 순수 구문외에 의미론적 사용 규칙이 내재
  - 중괄호는 문 블록, 객체 리터럴이 될 수 있음
- 자바스크립트 연산자는 우선순위와 결합성이 정해져 있음
- ASI(자동 세미콜론 삽입)는 자바스크립트 엔진에 내장된 파서 에러 감지 시스템으로 필요한 세미콜론이 누락된 경우 코드 실행에 문제가 없도록 도움
- 자바스크립트 에러는 크게 조기 에러와 런타임 에러로 분류
- arguments 배열은 조심하지 않으면 구멍 난 추상화에서 비롯된 갖가지 함정에 빠질 수 있음
  - 가급적 사용을 자제하되, 사용해야 하는 경우 arguments의 원소와 이에 대응하는 명명된 인자를 동시에 사용하지 말 것
- `try ... finally`에서 finally 절은 반드시 실행되며 try 이후 부터 항상 실행
- switch는 if 문이 많을 때 대체하는 훌륭한 수단이지만 예기치 않은 결과를 낳을 수 있음

## Part 2 스코프와 클로저

### 1. 스코프란 무엇인가

- 스코프란 어디서 어떻게 변수를 찾는가를 결정하는 규칙의 집합
  - LHS: 변수에 값을 대입
  - RHS: 변수의 값을 얻어옴
- LHS 참조는 대입 연산 과정에서 발생
  - = 연산자를 사용하거나, 함수의 인자로 넘겨줄 때 발생
- 엔진은 `var a = 2;`와 같은 구문을 독립된 두 단계로 나눔
  - `var a` 는 변수 a를 해당 스코프에 선언, 이 단계는 코드 실행 전에 처음부터 수행
  - `a = 2`는 변수 a를 찾아 값을 대입
- LHS와 RHS 참조 검색은 모두 현재 실행 중인 스코프에서 시작하며 상위 스코프로 넘어가며 확인자를 찾고 글로벌 스코프에 이르면 작업을 중단
- RHS 참조가 대상을 찾지 못하면 ReferenceError가 발생하며, LHS 참조가 대상을 찾지 못하면 자동적, 암시적으로 글로벌 스코프에 같은 이름의 새로운 변수가 생성

### 2. 렉시컬 스코프

- 렉시컬 스코프란 프로그래머가 코드를 작성할 때 함수를 어디에 선언하는 지에 따라 정의되는 스코프
- 자바스크립트에는 렉시컬 스코프를 속이는 두 가지 방식 `eval()`, `with`
  - `eval()`은 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 이를 수정
  - `with`는 객체 참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 새로운 렉시컬 스코프를 생성
- `eval()`과 `with`는 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킴
  - 이들이 수행되면 엔진은 최악의 경우를 대비해 진행했던 최적화 결과가 무효화됐다고 가정해야 하기 때문에 `eval()`과 `with`의 사용한 코드는 더 느리게 동작하므로 사용하지 않을 것

### 3. 함수 vs 블록 스코프

- 함수는 스코프를 이루는 가장 흔한 단위
  - 다른 함수 안에서 선언된 변수와 함수는 본질적으로 다른 스코프로부터 숨겨진 것이며, 좋은 소프트웨어를 위해 적용해야할 디자인 원칙
- 함수는 유일한 스코프 단위가 아니며, 블록 스코프는 함수만이 아니라 임의의 코드 블록에 변수와 함수가 속하는 개념
- ES3부터 시작해서 try/catch 구조의 catch 부분은 블록 스코프를 가지며, ES6에서는 키워드 let이 추가되어 임의의 코드 블록 안에 변수를 선언이 가능
- 블록 스코프는 var 함수 스코프를 완전히 대체할 수 없음

### 4. 호이스팅

- `var a = 2;`에서 엔진은 `var a`와 `a = 2`라는 독립된 두 개의 구문으로 보고, 첫 번째 구문은 컴파일러 단계에서 처리하고 두 번째 구문은 실행 단계에서 처리
  - 스코프의 모든 선언문은 실행 전에 먼저 처리
- 호이스팅은 선언문 각각이 속한 스코프의 꼭대기로 끌어올려 지는 작업
  - 선언문 자체는 옮겨지지만 함수 표현식의 대입문을 포함한 모든 대입문은 끌어올려 지지 않음

### 5. 스코프 클로저

- 클로저는 표준이며 함수를 값으로 넘길 수 있는 렉시컬 스코프 환경에서 코드를 작성하는 방법
- 클로저는 함수를 렉시컬 스코프 밖에서 호출해도 함수는 자신의 렉시컬 스코프를 기억하고접근할 수 잇는 특성
- 클로저는 다양한 모듈 패턴을 가능하게 하는 매우 효과적인 도구
- 모듈은 두 가지 특징을 가져야 함
  - 최외곽 래퍼 함수를 호출하여 외곽 스코프를 생성
  - 래핑 함수의 반환 값은 반드시 하나 이상의 내부 함수 참조를 가져야 하고, 그 내부 함수는 래퍼의 비공개 내부 스코프에 대한 클로저를 자여야 함
