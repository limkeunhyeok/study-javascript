# Part 2 스코프와 클로저

## Chapter 3 함수 vs 블록 스코프

### 1. 함수 기반 스코프

<p>
    각각의 선언된 함수는 저마다의 버블을 생성하지만 다른 어떤 자료 구조도 자체적인 스코프를 생성하지 않는다.
</p>

```javascript
function foo(a) {
    var b = 2;
    // some code

    function bar() {
        // ...
    }
    // more code
    var c = 3;
}
```

<p>
    `foo()`의 스코프 버블은 확인자 a, b, c와 bar를 포함한다. 스코프 안에 있는 모든 변수와 함수는 그 스코프 버블에 속한다. `bar()`는 자체 스코프 블록이 있고 글로벌 스코프도 마찬가지다. 그리고 글로벌 스코프에는 `foo`라는 하나의 확인자가 있다.
</p>

<p>
    a, b, c, bar 모두 `foo()`의 스코프 버블에 속하므로 `foo()` 바깥에서는 이들에게 접근할 수 없다. 따라서 다음 코드는 ReferenceError 오류를 발생시킨다.
</p>

```javascript
bar(); // fails
console.log(a, b, c); // all 3 fail
```

<p>
    모든 확인자(a, b, c, foo, bar)는 `foo()` 안에서 접근할 수 있고, `bar()` 안에서도 이용할 수 있다.
</p>

<p>
    함수 스코프는 모든 변수가 함수에 속하고 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다. 이런 디자인 접근법은 상당히 유용하고 자바스크립트 변수의 동적 특성을 완전히 살려 다른 타입의 값을 필요에 따라 가져올 수 있지만, 스코프 전체에서 변수가 살아있다는 점이 예상치 못한 문제를 일으킬 수도 있다.
</p>

### 2. 일반 스코프에 숨기

- 함수에 대한 전통적인 개념
  - 함수를 선언하고 그 안에 코드를 넣는다. 바꿔 생각해보는 것도 꽤 유용하다.
  - 작성한 코드에서 임의 부분을 함수 선언문으로 감싼다. 이는 해당 코드를 숨기는 효과를 낸다.

<p>
    스코프를 이용해 숨기는 방식을 사용하는 이유는 여러 가지가 있는데, 소프트웨어 디자인 원칙인 '최소 권한의 원칙'과 관련이 있다. 이 원칙은 모듈/객체의 API와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 숨겨야 한다는 것이다.
</p>

```javascript
function doSomething(a) {
    b = a + doSomethingElse(a * 2);

    console.log(b * 3);
}

function doSomethingElse(a) {
    return a - 1;
}

var b;
doSomething(2); // 15
```

<p>
    위 코드에서 변수 b와 함수 `doSomethingElse()`는 `doSomething()`이 어떤 작업을 하는지 보여주는 비공개 부분이라 할 수 있다. 변수 b와 `doSomethingElse()`에 접근할 수 있도록 내버려 두는 것은 불필요할 뿐 아니라 위험할 수도 있다.
</p>

```javascript
function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }
    var b;
    b = a + doSomethingElse(a * 2);
    console.log(b * 3);
}

doSomething(2); // 15
```

<p>
    위의 코드는 앞선 코드의 비공개 부분을 `doSomething()` 스코프 내부에 숨긴 것이다. b와 `doSomethingElse()`는 외부에서 접근할 수 없고, 오직 `doSomething()`만이 통제한다.
</p>

#### 충돌 회피

<p>
    변수와 함수를 스코프 안에 숨기는 것의 또 다른 장점은 같은 이름을 가졌지만 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있다.
</p>

```javascript
function foo() {
    function bar(a) {
        i = 3; // changing the `i` in the enclosing scope's
        // for-loop
        console.log(a + i)
    }

    for (var i = 0; i < 10; i++) {
        bar(i * 2); // oops, infinite loop ahead!
    }
}
foo();
```

<p>
    `bar()` 내부의 대입문 `i = 3`은 예기치 않게 `foo()`에서 `for` 반복문을 위해 선언된 변수 i의 값을 변경한다. 그 결과 위의 코드는 무한 반복에 빠진다. i의 값이 3으로 고정되어 계속 `i < 10`인 상태로 머물기 때문이다.
</p>

<p>
    `bar()` 내부의 대입문은 어떤 확인자 이름을 고르든 지역 변수로 선언해서 사용해야 한다. `var i = 3;`으로 변경하면 문제를 해결할 수 있다.
</p>

##### 글로벌 네임스페이스

<p>
    내부/비공개 함수와 변수가 적절하게 숨겨져 있지 않은 여러 라이브러리를 한 프로그램에서 불러오면 라이브러리들은 서로 쉽게 충돌한다. 이런 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 생성한다. 이후 객체는 해당 라이브러리의 네임스페이스로 이용된다. 네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능이 노출된다.
</p>

```javascript
var MyReallyCoolLibrary = {
    awesome: 'stuff',
    doSomething: function() {
        // ...
    },
    doAnotherThing: function() {
        // ...
    }
}
```

##### 모듈 관리

<p>
    현대적인 충돌 방지 옵션으로는 다양한 의존성 관리자를 이용한 모듈 접근법이 있다. 이 도구를 사용하면 어떤 라이브러리도 확인자를 글로벌 스코프에 추가할 필요 없이, 특정 스코프로부터 의존성 관리자를 이용한 다양한 명시적인 방법으로 확인자를 가져와 사용할 수 있다.
</p>

<p>
    이런 도구의 사용이 렉시컬 스코프 규칙에서 벗어날 수 있는 것이 아니다. 의존성 관리자는 그저 모든 확인자가 공유 스코프에 노출되는 것을 방지하고, 우발적인 스코프 충돌을 예방하기 위해 충돌 위험이 없는 비공개 스코프에 확인자를 보관한다.
</p>
