# Part 1 타입과 문법

## Chapter 4 강제변환

### 1. 값 변환

<p>
    어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 타입 캐스팅(Type Casting), 암시적이면 강제변환(Coercion)이라고 한다. 명시적 강제변환은 아래의 코드처럼 의도적으로 타입변환을 일으킨다는 사실이 명백한 방면, 암시적 강제변환은 다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환이다.
</p>

```javascript
var a = 42;
var b = a + ''; // 암시적 강제변환
var c = String(a); // 명시적 강제변환
```

<p>
    `명시적(Explicit) : 암시적(Implicit) = 명백한(Obvious) : 숨겨진 부수 효과(Hidden Side Effect)` 용어상으로는 이러한 대응 관계가 성립한다. 하지만 명시적인가 암시적인가의 문제는 개발자들 사이에서 관점에 따라 다를 수도 있다.
</p>

### 2. 추상 연산

#### ToString

<p>
    `문자열이 아닌 값 -> 문자역 변환 작업`은 ToString 추상 연산 로직이 담당한다. 내장 원시 값은 본연의 문자열화 방법이 정해져있다. 숫자는 그냥 문자열로 바뀌며 너무 작거나 큰 값은 지수 형태로 바뀐다.
</p>

```javascript

var a = {
    a : 'abc',
    b : 2
};

console.log(a.toString()) // [object Object]
```

<p>
    일반 객체는 특별히 지정하지 않으면 기본적으로 내부 [[Class]]를 반환한다. 배열은 기본적으로 재정의된 toString이 있어, 모든 원소 값이 콤마로 분리된 형태를 반환한다.
</p>

<p>
    대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는 JSON 문자열화나 toString() 변환이나 기본적으로 같은 로직이다. JSON 안전 값(JSON-Safe-Value: JSON 표현형으로 확실히 나타낼 수 있는 값)은 모두 JSON.stringify()로 문자열화할 수 있다. JSON.stringify()는 인자가 undefined, 함수, 심벌 값이면 자동으로 누락시키며 이런 값들이 배열에 포함되어 있으면 null로 바꾸고, 객체 프로퍼티에 있으면 지워버린다.
</p>

```javascript
var o = {};

var a =  {
    b: 42,
    c: o,
    d: function(){}
};

// 'a'를 환형 참조 객체로 만든다.
o.e = a;

// 환형 참조 객체는 JSON 문자열화 시 에러가 난다.
//JSON.stringify(a);

// JSON 값으로 직렬화하는 함수를 따로 정의한다.
a.toJSON = function() {
    // 직렬화에 프로퍼티 'b'만 포함시킨다.
    return { b: this.b };
};

JSON.stringify(a); // "{"b":42}"
```

<p>
    위의 코드에서 toJSON()은 적절히 평범한 실제 값을 반환하고 문자열화 처리는 JSON.stringify()이 담당한다. toJSON()의 역활은 문자열화하기 적당한 JSON 안전 값으로 바꾸는 것이지 JSON 문자열로 바꾸는 것이 아니다.
</p>

```javascript
var a = {
    b: 42,
    c: "42",
    d: [1, 2, 3]
};

console.log(JSON.stringify(a, ["b", "c"])); // {"b":42,"c":"42"}
console.log(JSON.stringify(a, function(k, v) {
    if (k !== "c") {
        return v;
    };
})); // {"b":42,"d":[1,2,3]}
```

<p>
    배열 아니면 함수 형태의 대체자(Replacer)를 JSON.stringify()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 필터링하는 방법이 있다. 대체자가 배열이면 전체 원소는 문자열이어야 하고 각 원소는 객체 직렬화의 대상 프로퍼티명이다. 즉, 여기에 포함되지 않은 프로퍼티는 직렬화 과정에서 빠진다. 대체자가 함수이면 처음 한 번은 객체 자신에 대해, 그 다음은 각 객체 프로퍼티별로 한 번씩 실행하면서 매번 키와 값 두 인자를 전달한다. 직렬화 과정에서 해당 키를 건너뛰려면 undefined를, 그 외엔 해당 값을 반환한다.
</p>

<p>
    JSON.stringify()의 세 번째 선택 인자는 스페이스라고 하며 사람이 읽기 쉽도록 들여쓰기 할 수 있다. 숫자를 주어 들여쓰기할 빈 공간의 개수를 지정한다.
</p>

#### ToNumber

<p>
    `숫자 아닌 값 -> 수식 연산이 가능한 숫자` 변환 로직은 ToNumber 추상 연산에 잘 정의되어 있다. true는 1, false는 0, undefined는 NaN, null은 0으로 바뀐다. 문자열 값에 ToNumber를 적용하면 대부분 숫자 리터럴 규칙/구문과 비슷하게 작동한다. 변환이 실패하면 결과는 NaN이다. 객체는 일당 동등한 원시 값으로 변환 후 그 결과 값을 ToNumber 규칙에 의해 강제변환한다.
</p>

#### ToBoolean

<p>
    자바스크립트에서 숫자는 숫자고 불리언은 불리언으로 서로 별개다. 1을 true로, 0을 false로 강제변환할 수는 있지만 그렇다고 두 값은 똑같은 건 아니다. 
</p>

##### Falsy

<p>
    명세가 정의한 falsy 값은 다음과 같다.
</p>

- undefined
- null
- false
- +0, -0, NaN
- ""

<p>
    위의 falsy 값 목록에 없으면 모두 truthy 값이다. falsy 객체는 일반적인 자바스크립트의 의미(Semantics)뿐만 아니라 브라우저만의 특이한 작동 방식을 가진 값을 생성하는 경우를 말한다.
</p>

<p>
    falsy 객체의 가장 유명한 사례는 DOM에서 사용했던 유사 배열(객체) document.all이다. document.all을 불리언으로 강제변환한 결과 값을 오래된, 비표준 IE 브라우저를 감지하는 수단으로써 사용해왔다. 하지만 document.all은 비표준이며, 오래전에 비 권장/폐기되었다. 
</p>

##### truthy 값

<p>
    truthy 값은 매우 많아 일일이 작성하는 게 불가능하며, falsy 값 목록에 없으면 무조건 truthy 값이다.
</p>

```javascript
var a = 'false';
var b = "0";
var c = "' '";
var d = [];
var e = {};
var f = function(){}
var g = Boolean(a && b && c && d && e && f);

console.log(g) // true
```

<p>
    truthy/falsy 개념은 어떤 값을 불리언 타입으로 강제변환 시 해당 값의 동작 방식을 이해한다는 점에서 중요하다.
</p>