# Part 1 타입과 문법

## Chapter 5 문법

### 1. 문과 표현식

#### 문의 완료 값

<p>
    모든 문은 완료 값(Completion Value)을 가진다. 브라우저 개발자 콘솔 창에서 문은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력한다. `var b = a`에서, 할당 표현식 `b = a`는 할당 이후의 값이 완료 값이지만 var 문 자체의 완료 값은 undefined이다. 블록 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.
</p>

<p>
    완료 값을 포착하는 방법으로 eval() 함수의 사용이 있다. 하지만 eval() 코드는 사용하지 않는 것을 권장한다.
</p>

```javascript
var a, b;

a = do {
    if (true) {
        b = 4 + 38;
    }
};

a; // 42
```

<p>
    ES7 명세에는 do 표현식이 제안된 상태이다. do {} 표현식은 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.
</p>

#### 표현식의 부수 효과

```javascript
function foo() {
    a = a + 1;
}

var a = 1;
foo(); // 결괏값: undefined, 부수 효과: a가 변경됨
```

<p>
    대부분의 표현식에는 부수 효과가 없지만, 일부 표현식에 따라 부수 효과를 가질 수도 있다. 위의 예시에서 함수 호출 표현식은 부수 효과를 가진 표현식의 전형적인 예시이다.
</p>

```javascript
var a = 42;
var b = a++;

a; // 43
b; // 42
```

<p>
    위의 예시에서 표현식 `a++`은, a의 현재 값 42를 반환 및 b에 할당하고 a 값을 1만큼 증가시킨다. ++를 전위(Prefix) 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 부수 효과를 일으킨다. 반면, 후위(Postfix) 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.
</p>

<p>
    ()로 둘러싼다해도 a++ 표현시겡서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다. 하지만 문을 나열하는(Statement-Series) 콤마 연산자를 사용하면 다수의 개별 표현식을 하나의 문을 연결할 수 있다.
</p>

```javascript
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```

<p>
    `a++, a` 표현식은 두 번째 a 표현식을 첫 번째 `a++` 표현식에서 부수 효과가 발생한 이후에 평가한다. 따라서 b 값은 43이 된다.
</p>

<p>
    `delete`도 부수 효과를 일으키는 연산자다. `delete`는 객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 쓴다. 하지만 단독 문(Standalone Statement)으로 더 많이 사용한다.
</p>

```javascript
var a;

a = 42; // 42
a; // 42
```

<p>
    = 할당 연산자도 부수 효과를 발생시키는 연산자다. `a = 42` 문의 실행 결과는 이제 막 할당된 값이므로 42를 할당하는 자체가 본질적으로 부수 효과이다. +=, -= 등의 복합 할당 연산자 역시 부수 효과를 가진다. 예를 들어 `a = b += 2` 문에서 `b += 2`이 먼저 처리되고, 그 후의 결과 값을 a에 할당한다. 이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 연쇄 할당문(Chained Assignment)에서 유용하다.
</p>

#### 콘텍스트 규칙

<p>
    자바스크립트 문법 규칙 중에는 같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 자바스크립트에서 중괄호가 나올 법한 곳은 크게 두 군데다.
</p>

##### 객체 리터럴

```javascript
// bar() 함수는 앞에서 정의되었다

var a = {
    foo: bar()
};
```

<p>
    위의 예시에서 중괄호는 a에 핧당될 값이므로 객체 리터럴이다.
</p>

##### 레이블

```javascript
// 앞선 예시에서 var a = 부분을 삭제한다면
{
    foo: bar()
}
```

<p>
    위의 예시에서 {}는 평범한 코드 블록이다. 자연스럽지는 않지만 문법적으로 옳은 코드이다. 이유는 자바스크립트에서 레이블 문(Labeled Statement)이라 부르는, 거의 잘 알려지지 않은 기능 덕분이다. 즉, `foo`는 `bar()` 문의 레이블이다. 제한적이기는 해도 자바스크립트에는 레이블 점프(Labeled Jump)라는 특별한 형태의 `goto` 장치가 마련되어 있다. `continue`와 `break` 문은 선택적으로 어떤 레이블을 받아 `goto`처럼 프로그램의 실행 흐름을 점프시킨다.
</p>

```javascript
foo: for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
        if ((i * j) >= 3) {
            console.log('그만!', i, j);
            break foo;
        }

        console.log(i, j);
    }
}

// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// 그만! 1 3`
```

<p>
    위의 예시에서 `break foo`는 foo라는 레이블이 붙은 바깥쪽 루프/블록으로 나가 그 이후부터 계속하라는 뜻이다. 전통적인 `goto`와는 의미가 사뭇 다르다. 레이블은 비 루프(Nonloop) 블록에 적용할 수 있는데, 단 이런 비 루프 레이블은 break만 참조할 수 있다.
</p>

<p>
    레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석도 많아 가능한 피하는게 좋다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 레이블 점프 기능을 사용할 의도라면 뜻한 바를 주석으로 잘 문서화해야 한다.
</p>

<p>
    JSON 문자열 `{"a":42}`에서, 자바스크립트 문의 레이블은 따옴표로 감싸면 안 되기 때문에 "a"는 문법에 맞는 레이블이 아니다. 따라서 JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다.
</p>

##### 블록

```javascript
[] + {}; // [object Object]
{} + []; // 0
```

<p>
    위 예시의 윗 줄 코드에서 엔진은 + 연산자 표현식의 {}를 실제 값으로 해석한다. 하지만 아랫 줄의 {}는 동떨어진 빈 블록으로 간주한다.
</p>

##### 객체 분해

<p>
    ES6부터는 분해 할당(Destructuring Assignments), 구체적으로는 객체 분해 시 {}를 사용한다.
</p>

```javascript
function getData() {
    // ...
    return {
        a: 42,
        b: "foo"
    };
}

var {a, b} = getData();

console.log(a, b);  // 42, "foo"
```

<p>
    위 예시에서 `var {a, b} = ...`이 ES6 분해 할당의 형식이며, 의미는 아래의 코드와 같다.
</p>

```javascript
var res = getData();
var a = res.a;
var b = res.b;
```

##### else if와 선택적 블록

<p>
    사실 `else if` 같은 건 없다. 자바스크립트 문법의 숨겨진 특성이다. 즉, `else if`라고 쓰는 건 표준 스타일 가이드의 위반 사례가 되며, 단일 if문과 같이 else를 정의한 셈이 된다. 하지만 `else if`는 누구나 사용하는 관용 코드이고, 한 단계 하위로 들여 쓰기를 하는 효과가 있다. 결국은 어떤 식으로 코딩하든 자신의 스타일 가이드와 규칙을 명시적으로 준수하고 `else if`를 정확한 문법 규칙인 것 처럼 넘겨짚지는 않도록 한다.
</p>

### 2. 연산자 우선순위

<p>
    연산자 우선순위(operator precedence)는 표현식에 연산자가 여러 개 있을 경우 어떤 규칙으로 처리되는 지를 결정한다. 모든 프로그래밍 언어에는 연산자 우선순위 리스트가 있다.
</p>

```javascript
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```

```javascript
var a = 42, b;
b = a++, a;

a; // 43
b; // 42
// , 연산자가 = 연산자보다 낮기 때문
```

#### 단락 평가

<p>
    &&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛰며, 단락(Short Circuited)라는 말이 유래되었다.
</p>

```javascript
function doSomething(opts) {
    if (opts && opts.cool) {
        // ...
    }
}
```

<p>
    위의 예시에서 `opts && opts.cool`에서 opts는 일종의 가드다. 만약 `opts`가 존재하지 않는다면 당연히 `opts.cool` 표현식은 에러일 수 밖에 없다. 일단 `opts`를 먼저 단락 평가 해보고, 그 결과는 실패면 `opts.cool`은 자동으로 건너뛰어 결과적으로 에러나지 않는다. || 단락 평가도 마찬가지다.
</p>

#### 결합성

<p>
    일반적으로 연산자는 좌측부터 그룹핑이 일어나는지 우측부터 그룹핑이 일어나는지에 따라 좌측 결합성(Left-Associative) 또는 우측 결합성(Right-Associative)을 가진다. 처리 과정이 좌 -> 우인지, 우 -> 좌인지 하는 문제는, 함수 호출과 같이 표현식이 부수효과를 일으킬 수 있으므로 중요하다.
</p>

### 3. 세미콜론 자동 삽입

<p>
    ASI(Automatic Semicolon Insertion, 자동 세미콜론 삽입)는 자바스크립트 프로그램의 세미콜론이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다. 단 하나의 ;이라도 누락되면 자바스크립트 프로그램은 돌아가지 않는다.
</p>

#### 에러 정정

<p>
    명세에는 ASI가 에러 정정(Error Correction) 루틴이라고 씌어있다. 여기서 에러란 구체적으로 파서 에러(Parser Error)이다. 파서 에러는 프로그램을 부정확하게 잘못 코딩했기 때문에 발생하는 것이며, 그 외의 경우는 없다.
</p>

### 4. 에러

<p>
    자바스크립트에는 하위 에러 타입(TypeError, ReferenceError, SyntaxError) 뿐만 아니라, 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다. 자바스크립트에는 오래 전부터 조기 에러(Early Error)로 붙잡아 던지게 되어 있는 여러 가지 특정 조건들이 있었다. 구문 에러는 물론이고, 자바스크립트 문법에는 구문상 오류는 아니지만 허용되지 않는 것들도 정의되어 있다. 코드가 실행도 되기 전에 발생하므로 이런 에러는 `try ~ catch`로 잡을 수 없으며, 프로그램 파싱/컴파일이 실패한다.
</p>

```javascript
function foo(a, b, a) {} // 정상 실행
function bar(a, b, a) { "use strict"; }
```

<p>
    ES5 엄격 모드는 조기 에러가 더 많다. 위의 예시처럼 엄격 모드에서 함수 인자명은 중복될 수 없다.
</p>

#### 너무 이른 변수 사용

<P>
    ES6는 임시 데드 존(TDZ, Temporal Dead Zone)이라는 새로운 개념을 도입했다. TDZ는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.
</p>

```javascript
{
    a = 2; // ReferenceError!
    let a;
}
```

<p>
    위의 예시처럼 ES6의 `let` 블록 스코핑이 대표적이다. `let a` 선언에 초기화되기 전 `a = 2` 할당문이 변수 a에 접근하려고 하지만, a는 아직 TDZ 내부에 있으므로 에러가 난다. `typeof` 연산자는 선언되지 않은 변수 앞에 붙여도 오류가 나지 않지만 TDZ 참조 시에는 이러한 안전장치가 없다.
</p>

### 5. 함수 인자

```javascript
var b = 3;
function foo(a = 42, b = a + 1) {
    console.log(a, b);
}

foo(); // 42, 43
foo(undefined); // 42, 43
foo(5); // 5, 6
foo(void 0, 7); // 42, 7
foo(null); // null 1
```

<p>
    TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다. ES6 디폴트 인자 값은 함수에 인자를 넘기지 않거나 undefined를 전달했을 때 적용된다.
</p>

<p>
    `arguments`를 사용할 때, ES6 디폴트 인자 값이 `arguments` 배열 슬롯과 이에 대응하는 인자 값 간의 불일치를 초래할 수 있다. 인자를 넘기면 `arguments`의 슬롯과 인자가 연결되면서 항상 같은 값이 할당되지만 인자 없이 호출하면 전혀 연결되지 않는다. 이렇게 확실하지 않은 연결에 의존하여 코딩하는 것은 바람직하지 않다. 사실 연결 그 자체만 바도 잘 설계된 기능이라기보다 엔진 내부의 상세한 구현체를 노출시킨, 구멍난 추상화(Leaky Abstraction)이다.
</p>

<p>
    `arguments` 배열은 이제 비 권장 요소지만, 완전히 나쁜 것은 아니다. ES6 이전까지 `arguments`는 함수에 전달된 인자들을 배열 형태로 추출할 수 있는 유일한 방법이었고 제법 유용하게 써왔다. 인자와 이 인자에 해당하는 `arguments` 슬롯을 동시에 참조하지 않는다라는 간단한 규칙만 준수한다면 `arguments` 배열과 인자를 섞어 사용해도 안전하다.
</p>

### 6. try ~ finally

<p>
    `finally` 절의 코드는 반드시 실행되고 다른 코드로 넘어가기 전에 `try` 이후부터 항상 실행된다.
</p>

```javascript
function foo() {
    try {
        return 42;
    }
    finally {
        console.log('hello');
    }
    console.log('실행되지 않는다');
}

console.log(foo());
// hello
// 42
```

<p>
    위의 예시의 `return 42`에서 foo() 함수의 완료 값은 42로 세팅되고, try 절의 실행이 종료되면서 곧바로 `finally` 절로 넘어간다. 그 후 foo() 함수 전체의 실행이 끝나고 완료 값은 호출부 `console.log()` 문에 반환된다.
</p>

```javascript
function foo() {
    try {
        throw 42;
    }
    finally {
        console.log('hello');
    }
    console.log('실행되지 않는다');
}

console.log(foo());
// hello
// Uncaught Exception: 42
```

<p>
    `throw`를 사용해도 비슷하다. 만약 `finally` 절에서 예외가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, 이전에 `try` 블록에서 생성한 완료 값이 있어도 완전히 사장된다.
</p>

```javascript
for (var i = 0; i < 10; i++) {
    try {
        continue;
    }
    finally {
        console.log(i);
    }
}
// 0 1 2 3 4 5 6 7 8 9
```

<p>
    `continue`나 `break` 같은 비선형(Nonlinear) 제어문도 `return`과 `throw`와 비슷하게 동작한다.
</p>

<p>
    `finally` 절의 `return`은 그 이전에 실행된 `try`나 `catch` 절의 `return`을 덮어쓰는 특출한 능력을 가지고 있는데, 단 반드시 명시적으로 `return` 문을 써야 한다.
</p>

<p>
    보통 함수에서는 `return`을 생략해도 `return;` 또는 `return undefined;`한 것으로 치지만, `finally` 안에서 `return`을 빼면 이전의 `return`을 무시하지 않는다.
</p>

### 7. switch

<p>
    `switch` 표현식은 평가 결과를 각 `case` 표현식의 값들과 매치한다. `switch` 표현식과 `case` 표현식 간의 매치 과정은 === 알고리즘과 같다. 강제변환이 일어나는 동등 비교를 이용하고 싶다면 아래의 코드처럼 구현한다.
</p>

```javascript
var a = '42';

switch (true) {
    case a == 10:
        console.log("10 또는 '10'");
        break;
    case a == 42:
        console.log("42 또는 '42'");
        break;
    default:
        // 여기엔 오지 않는다.
}
// 42 또는 '42'
```

<p>
    `case` 절에 표현식이 있으니 실행상 문제는 없다. 즉, `switch` 표현식의 결과(true)와 `case` 표현식의 결과를 엄격하게 매치한다. `a == 42`는 true이므로 여기서 매치된다. ==를 써도 `switch` 문은 엄격하게 매치한다. 그래서 `case` 표현식 평가 결과가 truthy이지만 엄격히 true가 아닐경우 매치는 실패한다.
</p>

<p>
    끝으로 `defalut` 절은 선택 사항이며 꼭 끝 부분에 쓸 필요는 없다. 그런데 `defalut`에서도 `break`를 안써면 그 이후로 코드가 계속 실행된다.
</p>
