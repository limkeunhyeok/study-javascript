# Part 1 타입과 문법

## Chapter 5 문법

### 1. 문과 표현식

#### 문의 완료 값

<p>
    모든 문은 완료 값(Completion Value)을 가진다. 브라우저 개발자 콘솔 창에서 문은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력한다. `var b = a`에서, 할당 표현식 `b = a`는 할당 이후의 값이 완료 값이지만 var 문 자체의 완료 값은 undefined이다. 블록 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.
</p>

<p>
    완료 값을 포착하는 방법으로 eval() 함수의 사용이 있다. 하지만 eval() 코드는 사용하지 않는 것을 권장한다.
</p>

```javascript
var a, b;

a = do {
    if (true) {
        b = 4 + 38;
    }
};

a; // 42
```

<p>
    ES7 명세에는 do 표현식이 제안된 상태이다. do {} 표현식은 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.
</p>

#### 표현식의 부수 효과

```javascript
function foo() {
    a = a + 1;
}

var a = 1;
foo(); // 결괏값: undefined, 부수 효과: a가 변경됨
```

<p>
    대부분의 표현식에는 부수 효과가 없지만, 일부 표현식에 따라 부수 효과를 가질 수도 있다. 위의 예시에서 함수 호출 표현식은 부수 효과를 가진 표현식의 전형적인 예시이다.
</p>

```javascript
var a = 42;
var b = a++;

a; // 43
b; // 42
```

<p>
    위의 예시에서 표현식 `a++`은, a의 현재 값 42를 반환 및 b에 할당하고 a 값을 1만큼 증가시킨다. ++를 전위(Prefix) 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 부수 효과를 일으킨다. 반면, 후위(Postfix) 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.
</p>

<p>
    ()로 둘러싼다해도 a++ 표현시겡서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다. 하지만 문을 나열하는(Statement-Series) 콤마 연산자를 사용하면 다수의 개별 표현식을 하나의 문을 연결할 수 있다.
</p>

```javascript
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```

<p>
    `a++, a` 표현식은 두 번째 a 표현식을 첫 번째 `a++` 표현식에서 부수 효과가 발생한 이후에 평가한다. 따라서 b 값은 43이 된다.
</p>

<p>
    `delete`도 부수 효과를 일으키는 연산자다. `delete`는 객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 쓴다. 하지만 단독 문(Standalone Statement)으로 더 많이 사용한다.
</p>

```javascript
var a;

a = 42; // 42
a; // 42
```

<p>
    = 할당 연산자도 부수 효과를 발생시키는 연산자다. `a = 42` 문의 실행 결과는 이제 막 할당된 값이므로 42를 할당하는 자체가 본질적으로 부수 효과이다. +=, -= 등의 복합 할당 연산자 역시 부수 효과를 가진다. 예를 들어 `a = b += 2` 문에서 `b += 2`이 먼저 처리되고, 그 후의 결과 값을 a에 할당한다. 이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 연쇄 할당문(Chained Assignment)에서 유용하다.
</p>

#### 콘텍스트 규칙

<p>
    자바스크립트 문법 규칙 중에는 같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 자바스크립트에서 중괄호가 나올 법한 곳은 크게 두 군데다.
</p>

##### 객체 리터럴

```javascript
// bar() 함수는 앞에서 정의되었다

var a = {
    foo: bar()
};
```

<p>
    위의 예시에서 중괄호는 a에 핧당될 값이므로 객체 리터럴이다.
</p>

##### 레이블

```javascript
// 앞선 예시에서 var a = 부분을 삭제한다면
{
    foo: bar()
}
```

<p>
    위의 예시에서 {}는 평범한 코드 블록이다. 자연스럽지는 않지만 문법적으로 옳은 코드이다. 이유는 자바스크립트에서 레이블 문(Labeled Statement)이라 부르는, 거의 잘 알려지지 않은 기능 덕분이다. 즉, `foo`는 `bar()` 문의 레이블이다. 제한적이기는 해도 자바스크립트에는 레이블 점프(Labeled Jump)라는 특별한 형태의 `goto` 장치가 마련되어 있다. `continue`와 `break` 문은 선택적으로 어떤 레이블을 받아 `goto`처럼 프로그램의 실행 흐름을 점프시킨다.
</p>

```javascript
foo: for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
        if ((i * j) >= 3) {
            console.log('그만!', i, j);
            break foo;
        }

        console.log(i, j);
    }
}

// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// 그만! 1 3`
```

<p>
    위의 예시에서 `break foo`는 foo라는 레이블이 붙은 바깥쪽 루프/블록으로 나가 그 이후부터 계속하라는 뜻이다. 전통적인 `goto`와는 의미가 사뭇 다르다. 레이블은 비 루프(Nonloop) 블록에 적용할 수 있는데, 단 이런 비 루프 레이블은 break만 참조할 수 있다.
</p>

<p>
    레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석도 많아 가능한 피하는게 좋다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 레이블 점프 기능을 사용할 의도라면 뜻한 바를 주석으로 잘 문서화해야 한다.
</p>

<p>
    JSON 문자열 `{"a":42}`에서, 자바스크립트 문의 레이블은 따옴표로 감싸면 안 되기 때문에 "a"는 문법에 맞는 레이블이 아니다. 따라서 JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다.
</p>

##### 블록

```javascript
[] + {}; // [object Object]
{} + []; // 0
```

<p>
    위 예시의 윗 줄 코드에서 엔진은 + 연산자 표현식의 {}를 실제 값으로 해석한다. 하지만 아랫 줄의 {}는 동떨어진 빈 블록으로 간주한다.
</p>

##### 객체 분해

<p>
    ES6부터는 분해 할당(Destructuring Assignments), 구체적으로는 객체 분해 시 {}를 사용한다.
</p>

```javascript
function getData() {
    // ...
    return {
        a: 42,
        b: "foo"
    };
}

var {a, b} = getData();

console.log(a, b);  // 42, "foo"
```

<p>
    위 예시에서 `var {a, b} = ...`이 ES6 분해 할당의 형식이며, 의미는 아래의 코드와 같다.
</p>

```javascript
var res = getData();
var a = res.a;
var b = res.b;
```

##### else if와 선택적 블록

<p>
    사실 `else if` 같은 건 없다. 자바스크립트 문법의 숨겨진 특성이다. 즉, `else if`라고 쓰는 건 표준 스타일 가이드의 위반 사례가 되며, 단일 if문과 같이 else를 정의한 셈이 된다. 하지만 `else if`는 누구나 사용하는 관용 코드이고, 한 단계 하위로 들여 쓰기를 하는 효과가 있다. 결국은 어떤 식으로 코딩하든 자신의 스타일 가이드와 규칙을 명시적으로 준수하고 `else if`를 정확한 문법 규칙인 것 처럼 넘겨짚지는 않도록 한다.
</p>

### 2. 연산자 우선순위

<p>
    연산자 우선순위(operator precedence)는 표현식에 연산자가 여러 개 있을 경우 어떤 규칙으로 처리되는 지를 결정한다. 모든 프로그래밍 언어에는 연산자 우선순위 리스트가 있다.
</p>

```javascript
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```

```javascript
var a = 42, b;
b = a++, a;

a; // 43
b; // 42
// , 연산자가 = 연산자보다 낮기 때문
```

#### 단락 평가

<p>
    &&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛰며, 단락(Short Circuited)라는 말이 유래되었다.
</p>

```javascript
function doSomething(opts) {
    if (opts && opts.cool) {
        // ...
    }
}
```

<p>
    위의 예시에서 `opts && opts.cool`에서 opts는 일종의 가드다. 만약 `opts`가 존재하지 않는다면 당연히 `opts.cool` 표현식은 에러일 수 밖에 없다. 일단 `opts`를 먼저 단락 평가 해보고, 그 결과는 실패면 `opts.cool`은 자동으로 건너뛰어 결과적으로 에러나지 않는다. || 단락 평가도 마찬가지다.
</p>

#### 결합성

<p>
    일반적으로 연산자는 좌측부터 그룹핑이 일어나는지 우측부터 그룹핑이 일어나는지에 따라 좌측 결합성(Left-Associative) 또는 우측 결합성(Right-Associative)을 가진다. 처리 과정이 좌 -> 우인지, 우 -> 좌인지 하는 문제는, 함수 호출과 같이 표현식이 부수효과를 일으킬 수 있으므로 중요하다.
</p>