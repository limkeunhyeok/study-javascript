# Part 2 스코프와 클로저

## Chapter 1 스코프란 무엇인가

> 프로그래밍 언어의 기본 패러다임 중 하나는 변수에 값을 저장하고 저장된 값을 가져다 쓰고 수정하는 것이다. 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하며, 이러한 규칙을 스코프(Scope)라 한다.

### 1. 컴파일러 이론

<p>
    자바스크립트는 컴파일러 언어다. 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 세련된 방식으로 처리한다. 전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스 코드가 실행되기 전에 보통 3단계를 거치는데, 이를 컴파일레이션(Compilation)이라고 한다.
</p>

#### 토크나이징(Tokenizing)/렉싱(Lexing)

<p>
    문자열을 나누어 토큰(token)이라 불리는 의미 있는 조각으로 만드는 과정이다. 토크나이징과 렉싱은 토큰을 인식할 때 무상태 방식으로 하는지 상태 유지 방식으로 하는지에 따라 구분한다.
</p>

#### 파싱(Parsing)

<p>
    파싱은 토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이며, 파싱의 결과로 만들어진 트리를 AST(Abstract Syntax Tree, 추상 구문 트리)라 부른다.
</p>

<p>
    `var a = 2;`의 트리는 먼저 변수 선언(variable Declaration)이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 'a'의 값을 가지는 확인자(Identifier)와 대입 수식(Assignment Expression)이라 부르는 자식 노드를 가진다. 대입 수식 노드는 '2'라는 값을 가지는 숫자 리터럴을 자식 노드로 가진다.
</p>

#### 코드 생성(Code-Generation)

<p>
    AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다. 언어에 따라 또는 목표하는 플랫폼에 따라 크게 달라진다. AST를 기계어 집합으로 바꾸어 실제로 'a'라는 변수를 생성하고 값을 저장한다.
</p>

<p>
    자바스크립트 엔진은 이 세 가지 단계뿐 아니라, 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화하는 등 좀 더 복잡하다.
</p>

### 2. 스코프 이해하기

- 엔진: 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
- 컴파일러: 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
- 스코프: 엔진의 또 다른 친구로, 선언된 모든 확인자 검색 목록을 작성하고 유지한다. 또한, 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정한다.

#### 앞과 뒤

<p>
    `var a = 2;`에서 엔진은 두 개의 서로 다른 구문으로 본다. 하나는 컴파일러가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 엔진이 처리할 구문이다.
</p>

<p>
    컴파일러는 먼저 렉싱을 통해 구문을 토큰으로 쪼갠다. 그 후 토큰을 파싱해 트리 구조로 만든다. 그러나 코드 생성 과정에 들어가면 컴파일러는 추측과 다르게 프로그램을 처리한다. 컴파일러는 다음 일을 진행한다.
</p>

1. 컴파일러가 `var a`를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
2. 그 후 컴파일러는 `a = 2` 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.

<p>
    요약하면 별개의 두가지 동작을 취하여 변수 대입문을 처리한다. 첫째로 컴파일러가 변수를 선언한다. 둘째로 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.
</p>

#### 컴파일러체

<p>
    2단계에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색한다. 이때 엔진이 어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라진다.
</p>

<p>
    검색은 대입 연산의 방향에 따라 LHS(Left-Hand-Side), RHS(Right-Hand-Side)로 나뉜다. 개념적으로 LHS는 대입할 대상, RHS는 대입한 값이다.
</p>

```javascript
function foo(a) {
    console.log(a); // 2
}
foo(2);
```

<p>
    위 예시의 마지막 줄에서 foo() 함수를 호출하는 데 RHS 참조를 사용한다. 또, 인수로 값 2를 함수로 넘겨줄 때, a에 대한 대입 연산을 위해 LHS 검색이 수행된다.
</p>

<p>
    변수 a에 대한 RHS 참조 역시 수행되는데, 그 결괏값은 console.log() 함수에 넘겨진다. 또, console.log()가 실행되려면 참조가 필요하다. console 객체를 RHS 검색하여 log 메서드가 있는지 확인한다.
</p>

<p>
    마지막으로 값 2를 RHS로 불러온 변수 a를 통해 log()에 넘겨주는 과정에서, 구현된 log()의 내부에는 인자가 있을 것이고, 첫 번째 인자를 LHS 검색으로 찾아 2를 대입한다.
</p>

### 3. 중첩 스코프

<p>
    스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이다. 스코프도 다른 스코프 안에 중첩(Nested)될 수 있다. 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾거나 글로벌 스코프라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다. 중첩 스코프를 탐사할 때 사용하는 규칙은 다음과 같다.
</p>

- 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
- 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

### 4. 오류

<p>
    두 종류의 검색 방식은 변수가 아직 선언되지 않았을 때 서로 다르게 동작한다.
</p>

```javascript
function foo(a) {
    console.log(a + b);
    b = a;
}
foo(2);
```

<p>
    b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다. 이렇게 스코프에서 찾지 못한 변수는 선언되지 않은 변수라 한다. RHS 검색이 중첩 스코프 안 어디에서도 변수를 참지 못하면 엔진이 ReferenceError를 발생시킨다.
</p>

<p>
    엔진이 LHS 검색을 수행하여 변수를 찾지 못하고 최상위 층에 도착할 때 프로그램이 Strict Mode로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다.
</p>

<p>
    Strict Mode에서는 글로벌 스코프는 변수를 생성하지 않아서 LHS 검색은 ReferenceError를 발생시킨다. 함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조할 때 엔진은 TypeError를 발생시킨다.
</p>
