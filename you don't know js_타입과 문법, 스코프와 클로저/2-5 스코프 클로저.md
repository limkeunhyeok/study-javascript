# Part 2 스코프와 클로저

## Chapter 5 스코프 클로저

### 1. 깨달음

<p>
    클로저는 자바스크립트의 모든 곳에 존재한다. 클로저는 새롭게 문법과 패턴을 배워야 할 특별한 도구가 아니다. 클로저는 렉시컬 스코프에 의존해 코드를 작성한 결과로 그냥 발생한다. 모든 코드에서 클로저는 생성되고 사용된다.
</p>

### 2. 핵심

<p>
    클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.
</p>

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log(a); // 2
    }
    bar();
}

foo();
```

<p>
    함수 `bar()`는 렉시컬 스코프 검색 규칙을 통해 바깥 스코프의 변수 a에 접근할 수 있다. a를 참조하는 `bar()`를 설명하는 가장 정확한 방식은 렉시컬 스코프 검색 규칙에 따라 설명하는 것이고, 이 규칙은 클로저의 일부일 뿐이다. 학술적인 관점에서 위의 코드는 함수 `bar()`는 `foo()` 스코프에 대한 클로저를 가진다. 달리 말하면 `bar()`는 `foo()` 스코프에서 닫힌다.
</p>

```javascript
function foo() {
    var = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}

var baz = foo();

baz(); // 2
```

<p>
    함수 `bar()`는 `foo()`의 렉시컬 스코프에 접근할 수 있고, `bar()` 함수 자체를 값으로 넘긴다. 이 코드는 bar를 참조하는 함수 객체 자체를 반환한다. `foo()`를 실행하여 반환한 값을 baz라 불리는 변수에 대입하고 실제로는 `baz()` 함수를 호출했다. 이 경우에 함수 bar는 함수가 선언된 렉시컬 스코프 밖에서 실행됐다.
</p>

<p>
    일반적으로 `foo()`가 실행된 후에는 `foo()`의 내부 스코프가 사라졌다고 생각할 수 있다. 엔진이 가비지 컬렉터를 고용해 메모리를 해제시키기 때문이다. 하지만 클로저는 이를 내버려두지 않는다. 사실 foo의 내부 스코프는 여전히 '사용 중'이므로 해제되지 않는다. 선언된 위치 덕에 `bar()`는 `foo()` 스코프에 대한 렉시컬 스코프 클로저를 가지고, `foo()`는 `bar()`가 나중에 참조할 수 있도록 스코프를 살려둔다. 즉, `bar()`는 여전히 해당 스코프에 대한 참조를 가지는데, 그 참조를 바로 클로저라고 부른다.
</p>

<p>
    함수는 원래 코드의 렉시컬 스코프에서 완전히 벗어나 호출됐다. 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다. 어떤 방식이든 함수를 값으로 넘겨 다른 위치에서 호출하는 행위는 모두 클로저가 작용한 예다.
</p>

### 3. 이제 나는 볼 수 있다

```javascript
function wait(message) {
    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}

wait('hello closure!');
```

<p>
    내부 함수 timer를 `setTimeout()`에 인자로 넘겼다. timer 함수는 `wait()` 함수의 스코프에 대한 스코프 클로저를 가지고 있으므로 변수 message에 대한 참조를 유지하고 사용할 수 있다. `wait()` 실행 1초 후, wait의 내부 스코프는 사라져야 하지만 익명의 함수가 여전히 해당 스코프에 대한 클로저를 가지고 있다.
</p>

<p>
    엔진 내부 깊숙한 곳의 내장 함수 `setTimeout()`에는 인자의 참조가 존재한다. 엔진은 해당 함수 참조를 호출하여 내장 함수 timer를 호출하므로 timer의 렉시컬 스코프는 여전히 온전하게 남아 있다.
</p>

#### 클로저

```javascript
function setupBot(name, selector) {
    $(selector).click(function activator() {
        console.log('Activating: ' + name);
    });
}

setupBot('Closure Bot 1', '#bot_1');
setupBot('Closure Bot 2', '#bot_2');
```

<p>
    자체의 렉시컬 스코프에 접근할 수 있는 함수를 인자로 넘길 때 그 함수가 클로저를 사용하는 것을 볼 수 있다. 타이머, 이벤트 처리기, Ajax 요청, 윈도 간 통신, 웹 워커와 같은 비동기적 작업을 하며 콜백 함수를 넘기면 클로저를 사용할 준비가 된 것이다.
</p>

<p>
    클로저는 기술적으로 보면 선언할 때 발생하지만, 바로 관찰할 수 있는 것은 아니다. IIFE 자체는 클로저의 사례가 아니지만, IIFE는 스코프를 생성하고 클로저를 사용할 수 있는 클로저를 사용할 수 있는 스코프를 만드는 가장 흔한 도구의 하나다. 따라서 IIFE 자체가 클로저를 작동시키지는 않아도 확실히 클로저와 연관이 깊다.
</p>

### 4. 반복문과 클로저

```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```

<p>
    위 코드의 목적은 1에서 5까지 일 초마다 출력하는 것이다. 하지만 코드를 돌려보면, 일 초마다 한 번씩 6만 5번 출력된다.
</p>

<p>
    반복문이 끝나는 조건은 `i <= 5`이므로, 끝나는 조건이 갖춰졌을 때 i의 값은 6이다. timeout 함수 콜백은 반복문이 끝나고 나서야 작동한다.
</p>

<p>
    원래의 목적을 구현하기 위해선, 반복마다 각각의 i 복제본을 잡아두는 것이다. 반복문 안 총 5개의 함수들은 반복마다 따로 정의됐음에도 모두 같이 글로벌 스코프 클로저를 공유해 해당 스코프 안에는 오직 하나의 i 만이 존재한다. 모든 함수는 당연하게도 같은 i에 대한 참조를 공유한다. 따라서 반복마다 하나의 새로운 닫힌 스코프가 필요하다.
</p>

```javascript
for (var i = 1; i <= 5; i++) {
    (function() {
        setTimeout(function timer() {
            console.log(i);
        }, i * 1000);
    })();
}
```

<p>
    위의 코드는 작동하지 않는다. 각각의 timeout 함수 콜백은 확실히 반복마다 IIFE가 생성한 자신만의 스코프를 가지지만, 스코프가 비어있기 때문이다. IIFE는 아무것도 하지 않는 빈 스코프이므로 각 스코프는 자체 변수가 필요하다. 즉 반복마다 i의 값을 저장할 변수가 필요하다.
</p>

```javascript
for (var i = 1; i <= 5; i++) {
    (function() {
        var j = i;
        setTimeout(function timer() {
            console.log(j);
        }, j * 1000);
    })();
}
```

<p>
    위의 코드 말고도 인자를 받는 스타일도 있다. IIFE를 사용하여 반복마다 새로운 스코프를 생성하는 방식으로 timeout 함수 콜백은 원하는 값이 제대로 저장된 변수를 가진 새 닫힌 스코프를 반복마다 생성해 사용할 수 있다.
</p>

#### 다시 보는 블록 스코프

<p>
    앞선 코드의 해법은 결국 반복 별 블록 스코프이다. 키워드 let은 본질적으로 하나의 블록을 닫을 수 있는 스코프로 바꾼다.
</p>

```javascript
for (var i = 1; i <= 5; i++) {
    let j = i;
    setTimeout(function timer() {
        console.log(j);
    }, j * 1000);
}
```

<p>
    let 선언문이 for 반복문 안에서 사용되면 특별한 방식으로 작동한다. 반복문 시작 부분에서 let으로 선언된 변수는 한 번만 선언되는 것이 아니라 반복할 때마다 선언된다.
</p>

```javascript
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i);
    }, i * 1000);
}
```
